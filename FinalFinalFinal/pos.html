<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Heung Boo Ne Garden POS</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>

/* ============================
   GLOBAL PAGE LAYOUT
   ============================ */
html {
  height: 100%;
}

body {
  margin: 0;
  padding: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #f3f3f3;
  height: 100vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  -webkit-text-size-adjust: 100%;
}

/* Touchscreen ergonomics: apply only on touch-first devices */
@media (pointer: coarse) {
  :root {
    --tap-min: 44px;
  }

  * {
    -webkit-tap-highlight-color: transparent;
  }

  /* Avoid sticky hover styles on touch screens */
  .floor-table:hover {
    transform: none;
  }

  .menu-tile:hover {
    background: #e8ffe8;
    transform: none;
  }

  /* Make common interactive elements easier to hit */
  button,
  #addTableBtn,
  .quick-add-btn,
  #reservedToggleBtn,
  #tableContextMenu .menu-item,
  .menu-tile,
  .cancel-item-btn,
  .choice-btn,
  .split-cell {
    min-height: var(--tap-min);
    touch-action: manipulation;
  }

  /* Top action buttons */
  #addTableBtn,
  .quick-add-btn {
    padding: 10px 12px;
    font-size: 14px;
    border-radius: 10px;
  }

  .table-tools {
    gap: 10px;
  }

  .table-tools button {
    font-size: 30px;
    padding: 6px;
  }

  /* Table tiles: keep layout similar but improve legibility/tapping */
  .floor-table {
    width: 96px;
    min-height: 96px;
    padding: 10px 10px;
    border-radius: 12px;
    font-size: 13px;
  }

  /* In edit mode, prevent the browser from treating table drags as scroll */
  #tableGrid.edit-mode .floor-table {
    touch-action: none;
    -webkit-touch-callout: none;
  }

  .table-label {
    font-size: 1.05em;
  }

  .table-eta,
  .table-menu,
  .table-pax,
  .table-status {
    font-size: 0.78em;
  }

  .pay-btn,
  .arrived-btn {
    font-size: 0.75em;
    padding: 6px 8px;
    border-radius: 8px;
  }

  .resize-handle {
    width: 18px;
    height: 18px;
    border-radius: 4px;
  }

  /* Context menu: bigger rows */
  #tableContextMenu {
    font-size: 15px;
    min-width: 180px;
  }

  #tableContextMenu .menu-item {
    padding: 12px 14px;
  }

  /* Menu grid tiles */
  #menuGridContainer {
    padding: 12px;
    -webkit-overflow-scrolling: touch;
  }

  .menu-grid {
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 12px;
  }

  .menu-tile {
    padding: 12px;
    font-size: 15px;
    border-radius: 12px;
  }

  .menu-title-ko {
    font-size: 16px;
  }

  .menu-price {
    font-size: 15px;
  }

  /* Modals/inputs: prevent iOS zoom and improve touch comfort */
  .modal-dialog {
    width: min(560px, 94vw);
  }

  .modal-form input,
  .modal-form select,
  .modal-form textarea {
    font-size: 16px;
    min-height: var(--tap-min);
  }

  .modal-form button {
    min-height: var(--tap-min);
    font-size: 16px;
  }

  .reservation-dialog .time-btn,
  .reservation-dialog .num-btn,
  .reservation-dialog .suggest-btn {
    min-height: 48px;
    font-size: 16px;
  }

  /* Any scrollable columns */
  #centerColumn,
  #rightColumn,
  .reserved-body {
    -webkit-overflow-scrolling: touch;
  }
}

/* Table map full width at top */
#tableMapContainer {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  overflow-y: hidden;
  background: #ffffff;
  border-radius: 0;
  padding: 0;
  box-shadow: none;
  margin: 0;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
}

#centerColumn {
  width: 80mm;
  min-width: 80mm;
  max-width: 80mm;
  margin: 8px 0;
  padding: 6px;
  box-sizing: border-box;
  overflow-y: auto;
  background: #f9f9f9;
  border-left: 2px solid #ccc;
  border-right: 2px solid #ccc;
  display: none;
}

#rightColumn {
  flex: 1;
  margin: 8px;
  margin-left: 0;
  padding: 10px 12px;
  box-sizing: border-box;
  overflow-y: auto;
  background: #f7f7f7;
  display: none;
}

/* Header row with title + (space for tools) */
.table-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0;
  padding-right: 70px; /* leave space for floating icons */
  flex-shrink: 0;
}

.table-header-actions {
  display: inline-flex;
  gap: 6px;
  align-items: center;
}

.table-title {
  font-weight: 700;
  font-size: 16px;
  color: #222;
}

/* +Table button */
#addTableBtn {
  padding: 3px 8px;
  font-size: 11px;
  font-weight: 700;
  border-radius: 6px;
  border: 1px solid #b0b0b0;
  background: #eeeeee;
  cursor: pointer;
}
#addTableBtn:hover {
  background: #e0e0e0;
}

/* POS quick-add buttons (same style as +Table) */
.quick-add-btn {
  padding: 3px 8px;
  font-size: 11px;
  font-weight: 700;
  border-radius: 6px;
  border: 1px solid #b0b0b0;
  background: #eeeeee;
  cursor: pointer;
}

.quick-add-btn:hover {
  background: #e0e0e0;
}

/* Reserved slide-out sidebar (right) */
#reservedSidebarBackdrop {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.45);
  z-index: 900;
  display: none;
}

#reservedSidebar {
  position: fixed;
  top: 0;
  right: 0;
  height: 100vh;
  width: min(420px, 92vw);
  background: #ffffff;
  z-index: 901;
  transform: translateX(102%);
  transition: transform 0.18s ease;
  box-shadow: -10px 0 28px rgba(0,0,0,0.22);
  display: flex;
  flex-direction: column;
}

#reservedSidebar.open {
  transform: translateX(0);
}

#reservedToggleBtn {
  position: fixed;
  top: 50%;
  right: 0;
  transform: translateY(-50%);
  width: 34px;
  height: 54px;
  border-radius: 12px 0 0 12px;
  border: 1px solid #cfcfcf;
  border-right: 0;
  background: #ffffff;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  line-height: 1;
  z-index: 902;
}

#reservedToggleBtn.open {
  right: min(420px, 92vw);
}

.reserved-header {
  padding: 12px 14px;
  border-bottom: 1px solid #e5e7eb;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
}

.reserved-title {
  font-weight: 800;
  font-size: 14px;
}

.reserved-sub {
  font-size: 12px;
  color: #555;
  margin-top: 2px;
}

.reserved-actions {
  display: inline-flex;
  gap: 8px;
  align-items: center;
}

.reserved-body {
  padding: 10px 12px 14px;
  overflow: auto;
  flex: 1;
}

.reserved-section {
  margin-bottom: 14px;
}

.reserved-section-title {
  font-weight: 800;
  font-size: 12px;
  color: #111;
  margin: 8px 0 6px;
}

.reserved-item {
  border: 1px solid #e5e7eb;
  border-radius: 10px;
  padding: 10px;
  background: #fff;
  margin-bottom: 8px;
}

.reserved-item-top {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  gap: 10px;
}

.reserved-item-top .left {
  font-weight: 800;
  font-size: 13px;
}

.reserved-item-top .right {
  font-weight: 800;
  font-size: 13px;
}

.reserved-kv {
  margin-top: 6px;
  display: grid;
  grid-template-columns: 1fr;
  gap: 4px;
  font-size: 12px;
  color: #333;
}

.reserved-empty {
  font-size: 12px;
  color: #555;
  padding: 6px 2px;
}

/* Floating tools (üõ† / üîÑ) in top-right of table area */
.table-tools {
  position: absolute;
  top: 8px;
  right: 8px;
  display: flex;
  gap: 6px;
  align-items: center;
  z-index: 5;
}

.table-tools button {
  border: none;
  background: transparent;
  cursor: pointer;
  font-size: 22px; /* medium size */
  line-height: 1;
  padding: 0 2px;
}

/* Batch actions (shown below tools when tables selected) */
.batch-actions {
  position: absolute;
  top: 40px;
  right: 8px;
  display: flex;
  flex-direction: column;
  gap: 4px;
  align-items: flex-end;
  z-index: 5;
}

.batch-actions button {
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  border: 1px solid #ccc;
  background: #fff;
  cursor: pointer;
  white-space: nowrap;
}

.batch-actions button:hover {
  background: #f0f0f0;
}

/* Edit Layout icon OFF = grey, ON = blue */
#editLayoutBtn {
  color: #888;
}
#editLayoutBtn.active {
  color: #1e88e5;
}

/* Select Tables icon OFF = grey, ON = green */
#selectTablesBtn {
  color: #888;
}
#selectTablesBtn.active {
  color: #4caf50;
}

/* FREE-POSITIONING CANVAS */
.table-grid {
  position: relative;
  width: 100%;
  background: #fafafa;
  overflow: hidden;
  flex: 1;
}

/* TABLE TILE (VACANT = GREEN) */
.floor-table {
  position: absolute;
  padding: 6px 6px;
  background: #e8f5e8; /* Light green for available */
  border: 2px solid #4caf50;
  border-radius: 10px;
  text-align: center;
  cursor: pointer;
  user-select: none;
  font-size: 12px;
  font-weight: 600;
  color: #1b4a1b;
  transition: background 0.15s, transform 0.05s, border-color 0.15s;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  min-height: 80px;
  width: 80px;
  overflow: hidden;
  box-sizing: border-box;
}

/* In-tile subdivision (divide one table into multiple sections) */
.floor-table.split {
  padding: 6px;
}

.split-overlay {
  position: absolute;
  inset: 0;
  display: grid;
  gap: 0;
  pointer-events: none; /* enabled dynamically when not in edit mode */
}

.split-cell {
  appearance: none;
  -webkit-appearance: none;
  border: 1px dashed #c7c7c7;
  background: transparent;
  padding: 0;
  margin: 0;
  cursor: pointer;
  font-size: 0.75em;
  color: inherit;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  position: relative;
}

.split-cell-num {
  font-weight: 800;
  opacity: 0.95;
  padding-top: 3px;
}

.split-cell-total {
  margin-top: auto;
  margin-bottom: 4px;
  font-weight: 800;
  font-size: 0.9em;
}

.split-cell.active {
  border-color: #e6b800;
}

/* Inner structure */
.floor-table .table-header {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  font-weight: 600;
  overflow: visible;
}

.table-label {
  font-size: 1.0em;
  font-weight: 700;
  margin-bottom: 2px;
  overflow: hidden;
  white-space: normal;
  word-wrap: break-word;
}

.table-eta, .table-menu, .table-pax, .table-status {
  font-size: 0.7em;
  margin-bottom: 1px;
  overflow: hidden;
  white-space: normal;
  word-wrap: break-word;
}

.table-content {
  margin-top: auto;
  overflow: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
}

.bill-amount {
  font-size: 0.75em;
  font-weight: 700;
  color: #2e7d32;
  overflow: hidden;
  white-space: normal;
  word-wrap: break-word;
}

.bill-splits {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  justify-content: center;
  font-size: 0.85em;
  font-weight: 700;
}

.bill-split-pill {
  border: 1px solid #4caf50;
  background: #e8f5e8;
  color: #1b4a1b;
  border-radius: 999px;
  padding: 2px 6px;
  line-height: 1.1;
  white-space: nowrap;
}

.pay-btn {
  font-size: 0.5em;
  padding: calc(1px * var(--scale, 1)) calc(2px * var(--scale, 1));
  margin-top: 2px;
  background: #1e88e5;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  position: absolute;
  top: var(--btn-pos, 2px);
  right: var(--btn-pos, 2px);
  z-index: 2;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.arrived-btn {
  font-size: 0.5em;
  padding: calc(1px * var(--scale, 1)) calc(2px * var(--scale, 1));
  background: #1e88e5;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  position: absolute;
  bottom: var(--btn-pos, 2px);
  left: var(--btn-pos, 2px);
  z-index: 2;
  line-height: 1;
  display: none; /* shown only for reserved tables */
  align-items: center;
  justify-content: center;
}

.resize-handle {
  position: absolute;
  bottom: var(--btn-pos, 2px);
  right: var(--btn-pos, 2px);
  width: calc(8px * var(--scale, 1));
  height: calc(8px * var(--scale, 1));
  background: #666;
  cursor: nw-resize;
  border-radius: 2px;
  z-index: 2;
}

/* When a table becomes very small, keep icons visible by placing them in-flow */
.floor-table.compact {
  justify-content: flex-start;
}

.floor-table.compact .pay-btn {
  position: static;
  align-self: flex-end;
  margin: 0 0 calc(2px * var(--scale, 1)) 0;
}

.floor-table.compact .arrived-btn {
  position: static;
  align-self: flex-start;
  margin: 0 0 calc(2px * var(--scale, 1)) 0;
}

/* Hover state */
.floor-table:hover {
  transform: scale(1.05);
  background: #c8e6c9;
}

/* SELECTED TABLE (yellow) */
.floor-table.selected {
  background: #fff7c2;
  border-color: #e6b800;
  color: #8a6a00;
}

/* MULTI-SELECTED TABLE (green) */
.floor-table.multi-selected {
  background: #e8f5e8;
  border-color: #4caf50;
  color: #2e7d32;
}

/* OCCUPIED TABLE (RED) ‚Äî has active bill */
.floor-table.occupied {
  background: #ffd6d6 !important;
  border-color: #c0392b !important;
  color: #7a1f16 !important;
}

.floor-table.occupied .table-status {
  color: #c0392b;
}

/* AVAILABLE TABLE (LIGHT GREEN) ‚Äî no active bill */
.floor-table.available {
  background: #e8f5e8;
  border-color: #4caf50;
}

/* RESERVED TABLE (ORANGE) ‚Äî has reservation */
.floor-table.reserved {
  background: #ffcc80;
  border-color: #ff9800;
  color: #e65100;
}

.floor-table.reserved .table-status {
  color: #e65100;
}

/* NEEDS CLEANING (after payment, no outstanding bill) */
.floor-table.needs-cleaning {
  background: #ffcc80;
  border-color: #ff9800;
  color: #e65100;
}

.floor-table.needs-cleaning .table-status {
  color: #e65100;
}

/* SELECTED + OCCUPIED = ORANGE */
.floor-table.selected.occupied {
  background: #ffedc5 !important;
  border-color: #e48f2e !important;
  color: #9a5200 !important;
}

/* SELECTED + RESERVED = DARK ORANGE */
.floor-table.selected.reserved {
  background: #ffb74d !important;
  border-color: #f57c00 !important;
  color: #bf360c !important;
}

/* ============================
   CUSTOM CONTEXT MENU
   ============================ */

#tableContextMenu {
  position: fixed;
  display: none;
  background: #ffffff;
  border: 1px solid #ccc;
  border-radius: 6px;
  box-shadow: 0 3px 8px rgba(0,0,0,0.20);
  font-size: 13px;
  z-index: 9999;
  min-width: 140px;
}

#tableContextMenu .menu-item {
  padding: 6px 10px;
  cursor: pointer;
  white-space: nowrap;
}

#tableContextMenu .menu-item:hover {
  background: #f0f0f0;
}

/* ============================
   MENU GRID
   ============================ */

#menuGridContainer {
  flex: 1;
  margin-top: 1px;
  overflow-y: auto;
  background: #ffffff;
  padding: 8px;
  border-radius: 8px;
  box-shadow: 0 0 4px rgba(0,0,0,0.12);
}

.menu-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  gap: 8px;
}

.menu-tile {
  background: #e8ffe8;
  border: 1px solid #66bb6a;
  border-radius: 8px;
  padding: 12px 6px;
  min-height: 70px;
  text-align: center;
  cursor: pointer;
  font-size: 13px;
  user-select: none;
  transition: background 0.15s, transform 0.05s;
  position: relative;
  display: flex;
  flex-direction: column;
  justify-content: center;
}

.menu-tile:hover {
  background: #d2ffd2;
}

.menu-tile.item-added {
  animation: itemAddedFlash 0.4s ease-out;
}

@keyframes itemAddedFlash {
  0% { transform: scale(1); background: #e8ffe8; }
  20% { transform: scale(1.08); background: #4CAF50; }
  40% { transform: scale(1.04); background: #81c784; }
  100% { transform: scale(1); background: #e8ffe8; }
}

.menu-qty-badge {
  position: absolute;
  top: -8px;
  right: -8px;
  background: #d32f2f;
  color: white;
  font-size: 13px;
  font-weight: 700;
  min-width: 24px;
  height: 24px;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  z-index: 10;
  padding: 0 5px;
}

.menu-qty-badge.badge-pop {
  animation: badgePop 0.3s ease-out;
}

@keyframes badgePop {
  0% { transform: scale(1); }
  50% { transform: scale(1.4); }
  100% { transform: scale(1); }
}

.menu-title-ko {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 4px;
}

.menu-price {
  font-size: 13px;
  color: #2e7d32;
  font-weight: 600;
}

/* ============================
   RECEIPT PREVIEW
   ============================ */

#receipt-area {
  position: relative;
  width: 72mm;
  margin: 4px auto;
  background: #ffffff;
  padding: 6px;
  border: 1px solid #bbb;
  box-sizing: border-box;
  font-family: "Consolas","Courier New",monospace;
  font-size: 12.2px;
  line-height: 1.28;
}

#receipt-text {
  white-space: pre;
}

#receipt-area::before {
  content: "";
  position: absolute;
  left: 50%;
  top: 300px;
  transform: translateX(-50%);
  width: 40mm;
  height: 40mm;
  /* background-image: url("watermark.jpg"); */
  background-repeat: no-repeat;
  background-position: center;
  background-size: contain;
  opacity: 0.12;
  pointer-events: none;
}

/* ============================
   RIGHT COLUMN ‚Äì POS INTERFACE
   ============================ */

#rightColumn h2 {
  margin: 4px 0 10px;
  font-size: 18px;
  font-weight: 600;
  color: #333;
}

.card {
  background: #ffffff;
  padding: 10px 10px 8px;
  margin-bottom: 12px;
  border-radius: 8px;
  box-shadow: 0 1px 4px rgba(0,0,0,0.10);
  transition: transform 0.12s ease, box-shadow 0.12s ease;
}

.card:hover {
  transform: translateY(-1px);
  box-shadow: 0 6px 18px rgba(0,0,0,0.12);
}

.card label {
  display: block;
  font-size: 12px;
  font-weight: 500;
  color: #444;
  margin-top: 4px;
  margin-bottom: 2px;
}

.card input,
.card select {
  width: 100%;
  box-sizing: border-box;
  padding: 4px 6px;
  font-size: 13px;
  border-radius: 4px;
  border: 1px solid #ccc;
  margin-bottom: 6px;
}

/* Reservation modal form */
#reservationForm label {
  display: block;
  font-size: 16px;
  font-weight: 700;
  color: #222;
  margin: 0 0 10px;
  text-align: center;
}

#reservationForm input,
#reservationForm select {
  width: 100%;
  box-sizing: border-box;
  padding: 12px 12px;
  font-size: 16px;
  border-radius: 12px;
  border: 1px solid #cfcfcf;
  background: #ffffff;
  box-shadow: 0 1px 0 rgba(0,0,0,0.04);
  text-align: center;
}

#reservationForm input::placeholder {
  color: #888;
}

.visually-hidden {
  position: absolute !important;
  left: -9999px !important;
  width: 1px !important;
  height: 1px !important;
  overflow: hidden !important;
}

/* Shared modal styling (used by Reservation + Divide) */
.modal-backdrop {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.5);
  backdrop-filter: blur(2px);
  z-index: 1000;
  justify-content: center;
  align-items: center;
  animation: backdropFade 0.14s ease;
}

.modal-dialog {
  background: white;
  padding: 20px;
  border-radius: 10px;
  max-width: 460px;
  width: calc(100% - 24px);
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 8px 26px rgba(0,0,0,0.18);
  animation: modalPop 0.16s ease;
  transform-origin: 50% 20%;
}

@keyframes backdropFade {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes modalPop {
  from {
    opacity: 0;
    transform: translateY(6px) scale(0.985);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* Apply modal polish to older popups that use inline styles */
#menuPopup,
#receiptPopup {
  backdrop-filter: blur(2px);
}

/* Admin popup (embed backend admin pages inside POS) */
#adminPopup {
  backdrop-filter: blur(2px);
}

#adminPopup > .admin-dialog {
  animation: modalPop 0.16s ease;
  box-shadow: 0 8px 26px rgba(0,0,0,0.18);
}

.admin-dialog {
  background: white;
  border-radius: 10px;
  width: min(1100px, calc(100% - 24px));
  height: min(86vh, 720px);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.admin-body {
  display: flex;
  min-height: 0;
  flex: 1;
}

.admin-frame-wrap {
  flex: 1;
  min-width: 0;
  min-height: 0;
  display: flex;
}

.admin-side {
  background: #0f172a;
  color: #ffffff;
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.admin-side a,
.admin-side button {
  appearance: none;
  border: none;
  background: rgba(255, 255, 255, 0.08);
  color: #e2e8f0;
  padding: 10px 10px;
  border-radius: 8px;
  cursor: pointer;
  text-align: left;
  font-size: 13px;
}

.admin-side a:hover,
.admin-side button:hover {
  background: rgba(255, 255, 255, 0.14);
}

.admin-frame {
  width: 100%;
  height: 100%;
  border: 0;
  background: #ffffff;
  flex: 1;
  display: block;
}

@media (max-width: 760px) {
  .admin-body {
    display: flex;
  }
}

/* Menu popup header actions: make Pay/Close fit nicely (em-based sizing) */
.menu-popup-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 1em;
  flex-wrap: wrap;
}

.menu-popup-actions {
  display: inline-flex;
  align-items: center;
  gap: 0.5em;
}

.menu-popup-actions button {
  font-size: 1em;
  padding: 0.55em 0.9em;
  line-height: 1.1;
}

#menuGridContainer,
#receiptPopup > div {
  animation: modalPop 0.16s ease;
  box-shadow: 0 8px 26px rgba(0,0,0,0.18);
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
}

.modal-form {
  margin-top: 10px;
}

/* Reservation modal: keep slider content truly centered */
.reservation-dialog .modal-form {
  margin-top: 0;
  flex: 1;
  display: flex;
  flex-direction: column;
}

.modal-form .form-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 12px;
}

.modal-form .form-field {
  display: flex;
  flex-direction: column;
}

.modal-form .form-field.full {
  grid-column: 1 / -1;
}

.modal-form label {
  margin: 0 0 3px;
  font-size: 12px;
  font-weight: 600;
  color: #444;
}

.modal-form input,
.modal-form select {
  width: 100%;
  box-sizing: border-box;
  padding: 6px 8px;
  font-size: 13px;
  border-radius: 6px;
  border: 1px solid #ccc;
}

.modal-form .form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  margin-top: 12px;
}

/* Reservation slider (step-by-step) */
.reservation-dialog {
  position: relative;
  max-width: 560px;
  width: min(560px, calc(100% - 24px));
  min-height: 520px;
  max-height: 86vh;
  display: flex;
  flex-direction: column;
}

.reservation-dialog .form-field {
  align-items: center;
}

.reservation-dialog .field-wrap {
  position: relative;
  width: 100%;
  max-width: 360px;
}

.reservation-dialog .field-wrap input {
  padding-right: 44px;
}

.reservation-dialog .field-icon-btn {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  width: 34px;
  height: 34px;
  border-radius: 10px;
  border: 1px solid #d6d6d6;
  background: #fff;
  padding: 0;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
}

.reservation-dialog .time-grid {
  margin-top: 12px;
  width: 100%;
  max-width: 420px;
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  gap: 8px;
  max-height: 220px;
  overflow: auto;
  padding: 10px;
  border-radius: 14px;
  border: 1px solid #e6e6e6;
  background: #fafafa;
}

.reservation-dialog .suggest-grid {
  margin-top: 12px;
  width: 100%;
  max-width: 420px;
  display: grid;
  grid-template-columns: 1fr;
  gap: 8px;
  max-height: 220px;
  overflow: auto;
  padding: 10px;
  border-radius: 14px;
  border: 1px solid #e6e6e6;
  background: #fafafa;
}

.reservation-dialog .suggest-btn {
  text-align: left;
  border-radius: 10px;
  border: 1px solid #dcdcdc;
  background: #fff;
  padding: 10px 10px;
  font-size: 13px;
  font-weight: 700;
  cursor: pointer;
}

.reservation-dialog .suggest-empty {
  border-radius: 10px;
  border: 1px dashed #dcdcdc;
  background: rgba(255,255,255,0.65);
  padding: 10px 10px;
  font-size: 12px;
  font-weight: 700;
  color: #666;
}

.reservation-dialog .time-btn {
  border-radius: 10px;
  border: 1px solid #dcdcdc;
  background: #fff;
  padding: 10px 6px;
  font-size: 13px;
  font-weight: 700;
}

.reservation-dialog .time-btn.selected {
  border-color: #1565c0;
  background: #1e88e5;
  color: #fff;
}

.reservation-dialog .num-pad {
  margin-top: 12px;
  width: 100%;
  max-width: 320px;
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 10px;
}

.reservation-dialog .num-btn {
  padding: 14px 10px;
  border-radius: 14px;
  border: 1px solid #dcdcdc;
  background: #fff;
  font-size: 16px;
  font-weight: 800;
}

.reservation-dialog .num-btn.utility {
  font-weight: 800;
}

.numpad-btn {
  padding: 18px 10px;
  border-radius: 12px;
  border: 1px solid #dcdcdc;
  background: #fff;
  font-size: 1.4rem;
  font-weight: 700;
  cursor: pointer;
  transition: background 0.15s, transform 0.1s;
}

.numpad-btn:hover {
  background: #f0f0f0;
}

.numpad-btn:active {
  transform: scale(0.95);
  background: #e0e0e0;
}

/* Toggle Switch */
.toggle-switch {
  position: relative;
  display: inline-block;
  width: 50px;
  height: 28px;
}

.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.toggle-slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .3s;
  border-radius: 28px;
}

.toggle-slider:before {
  position: absolute;
  content: "";
  height: 22px;
  width: 22px;
  left: 3px;
  bottom: 3px;
  background-color: white;
  transition: .3s;
  border-radius: 50%;
}

.toggle-switch input:checked + .toggle-slider {
  background-color: #4CAF50;
}

.toggle-switch input:checked + .toggle-slider:before {
  transform: translateX(22px);
}

.reservation-dialog .cal {
  margin-top: 10px;
  width: 100%;
  max-width: 420px;
  border-radius: 16px;
  border: 1px solid #e6e6e6;
  background: #fafafa;
  padding: 12px;
}

.reservation-dialog .cal-header {
  display: grid;
  grid-template-columns: 44px 1fr 44px;
  align-items: center;
  gap: 8px;
  margin-bottom: 10px;
}

.reservation-dialog .cal-label {
  text-align: center;
  font-size: 14px;
  font-weight: 800;
  color: #222;
}

.reservation-dialog .cal-nav {
  width: 44px;
  height: 40px;
  border-radius: 12px;
  border: 1px solid #dcdcdc;
  background: #fff;
  font-size: 20px;
  font-weight: 800;
  padding: 0;
}

.reservation-dialog .cal-weekdays {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 6px;
  margin-bottom: 8px;
  font-size: 11px;
  font-weight: 800;
  color: #666;
}

.reservation-dialog .cal-weekdays > div {
  text-align: center;
}

.reservation-dialog .cal-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 6px;
}

.reservation-dialog .cal-day {
  height: 40px;
  border-radius: 12px;
  border: 1px solid #dcdcdc;
  background: #fff;
  font-size: 13px;
  font-weight: 800;
  padding: 0;
}

.reservation-dialog .cal-day.other {
  opacity: 0.45;
}

.reservation-dialog .cal-day.today {
  border-color: rgba(30,136,229,0.45);
}

.reservation-dialog .cal-day.selected {
  border-color: #1565c0;
  background: #1e88e5;
  color: #fff;
}

.reservation-dialog .pax-confirm {
  width: 100%;
  max-width: 320px;
  padding: 12px 14px;
  border-radius: 14px;
  border: 2px solid #2e7d32;
  background: #e8f5e8;
  color: #1b4a1b;
  font-size: 15px;
  font-weight: 900;
}

.reservation-slider {
  overflow: hidden;
  width: 100%;
  margin-top: 0;
  touch-action: pan-y;
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0 64px;
}

.reservation-track {
  display: flex;
  width: 100%;
  transform: translateX(0%);
  transition: transform 0.22s ease;
  will-change: transform;
}

.reservation-slide {
  flex: 0 0 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 8px 18px;
}

.reservation-slide .form-field {
  width: 100%;
  max-width: 420px;
}

.reservation-dialog .field-wrap,
.reservation-dialog .time-grid,
.reservation-dialog .num-pad,
.reservation-dialog .cal {
  margin-left: auto;
  margin-right: auto;
}

.reservation-dialog .reservation-submit-wrap {
  margin-top: 16px;
  width: 100%;
  max-width: 360px;
  display: flex;
  justify-content: center;
}

.reservation-dialog .reservation-submit-wrap button {
  min-width: 180px;
  padding: 12px 14px;
  border-radius: 14px;
}

.reservation-slide input {
  height: 48px;
}

.reservation-next {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  width: 44px;
  height: 44px;
  border-radius: 22px;
  border: 1px solid #cfcfcf;
  background: #ffffff;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
  line-height: 1;
  transition: transform 0.12s ease, box-shadow 0.12s ease, filter 0.12s ease;
  z-index: 5;
}

.reservation-prev {
  position: absolute;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  width: 44px;
  height: 44px;
  border-radius: 22px;
  border: 1px solid #cfcfcf;
  background: #ffffff;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
  line-height: 1;
  transition: transform 0.12s ease, box-shadow 0.12s ease, filter 0.12s ease;
  z-index: 5;
}

.reservation-next:disabled {
  opacity: 0.4;
  cursor: default;
}

.reservation-prev:disabled {
  opacity: 0.4;
  cursor: default;
}

.reservation-next:hover:not(:disabled) {
  filter: brightness(1.02);
  box-shadow: 0 6px 16px rgba(0,0,0,0.14);
  transform: translateY(-50%) scale(1.02);
}

.reservation-prev:hover:not(:disabled) {
  filter: brightness(1.02);
  box-shadow: 0 6px 16px rgba(0,0,0,0.14);
  transform: translateY(-50%) scale(1.02);
}

.reservation-next:active:not(:disabled) {
  transform: translateY(-50%) scale(0.99);
}

.reservation-prev:active:not(:disabled) {
  transform: translateY(-50%) scale(0.99);
}

/* Divide modal preview diagram */
.divide-preview {
  grid-column: 1 / -1;
  display: flex;
  align-items: center;
  justify-content: center;
  padding-top: 4px;
}

.divide-preview-box {
  width: 180px;
  height: 120px;
  border: 2px solid #4caf50;
  border-radius: 10px;
  background: #e8f5e8;
  display: grid;
  overflow: hidden;
}

.divide-preview-cell {
  border: 1px dashed #c7c7c7;
  background: transparent;
}

/* Walk-in vs Reservation chooser */
.choice-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 12px;
  margin-top: 12px;
}

.choice-btn {
  padding: 12px 10px;
  border-radius: 10px;
  font-size: 14px;
  font-weight: 600;
  border: 2px solid #4caf50;
  background: #e8f5e8;
  color: #1b4a1b;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 4px;
  transition: transform 0.12s ease, box-shadow 0.12s ease, filter 0.12s ease;
}

.choice-btn.primary {
  border-color: #1565c0;
  background: #1e88e5;
  color: white;
}

.choice-btn.danger {
  border-color: #e53935;
  background: #e53935;
  color: white;
}

.choice-btn small {
  font-size: 12px;
  font-weight: 500;
  opacity: 0.9;
}

.choice-btn:hover {
  filter: brightness(1.02);
  box-shadow: 0 8px 18px rgba(0,0,0,0.14);
  transform: translateY(-1px);
}

.choice-btn:active {
  transform: translateY(0) scale(0.99);
}

.choice-btn:focus-visible {
  outline: 2px solid rgba(30,136,229,0.35);
  outline-offset: 2px;
}

button {
  padding: 6px 10px;
  border: 1px solid #ccc;
  background: #f7f7f7;
  border-radius: 5px;
  cursor: pointer;
  font-size: 13px;
}

button.primary {
  background: #1e88e5;
  color: white;
  border-color: #1565c0;
}

button.danger {
  background: #e53935;
  color: white;
}

/* POS bill table */
#billTable {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
}

.cancel-item-btn {
  padding: 2px 6px;
  font-size: 12px;
  line-height: 1;
}

#billTable th,
#billTable td {
  border-bottom: 1px solid #e0e0e0;
  padding: 4px;
}

#billTable th {
  text-align: left;
  font-weight: 600;
  background: #fafafa;
}

#billTable td:last-child {
  text-align: right;
}

/* Action buttons at bottom */
#rightColumn > button {
  margin-right: 6px;
  margin-top: 4px;
}

@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation: none !important;
    transition: none !important;
    scroll-behavior: auto !important;
  }
}

/* ============================
   PRINT ONLY RECEIPT
   ============================ */

@media print {
  body * { visibility: hidden !important; }
  #receipt-area, #receipt-area * {
    visibility: visible !important;
  }
  #receipt-area {
    position: absolute;
    left: 0;
    top: 0;
    width: 72mm !important;
    margin: 0 !important;
    padding: 0 !important;
    border: none !important;
    box-shadow: none !important;
  }
}

</style>
</head>

<body>

<!-- LEFT COLUMN -->
<div id="leftColumn">
  <!-- TABLE MAP -->
  <div id="tableMapContainer">
    <div class="table-header">
      <div class="table-title">Tables</div>
      <div class="table-header-actions">
        <button id="addTableBtn" type="button">+ Table</button>
        <button class="quick-add-btn" type="button" onclick="showAdminPopup('/menu.html')">+ Menu</button>
        <button class="quick-add-btn" type="button" onclick="showAdminPopup('/reservations.html')">+ Reservations</button>
      </div>
    </div>

    <!-- Floating tools (Edit Layout) -->
    <div class="table-tools">
      <button id="editLayoutBtn" type="button" title="Toggle edit layout">üõ†</button>
      <button id="selectTablesBtn" type="button" title="Toggle select tables">‚òë</button>
    </div>

    <!-- Batch actions (shown when tables selected) -->
    <div class="batch-actions" id="batchActions" style="display: none;">
      <button id="selectAllBtn" type="button" title="Select all tables">‚òë Select All</button>
      <button id="equalSizeBtn" type="button" title="Make selected tables equal size" style="display: none;">üìê Equal Size</button>
      <button id="paySelectedBtn" type="button" title="Pay selected tables" style="display: none;">üí∞ Pay Selected</button>
      <button id="clearSelectedBtn" type="button" title="Clear selected tables" style="display: none;">üóë Clear Selected</button>
      <button id="deselectAllBtn" type="button" title="Deselect all" style="display: none;">‚úñ Deselect All</button>
    </div>

    <div class="table-grid" id="tableGrid"></div>
  </div>
</div>

<!-- CENTER COLUMN -->
<div id="centerColumn">
  <div id="receipt-area">
    <pre id="receipt-text"></pre>
  </div>
</div>

<!-- RIGHT COLUMN -->
<div id="rightColumn">

  <h2>POS Interface</h2>

  <div class="card">
    <label>Customer</label>
    <select id="customer"></select>

    <label>Guide Name (optional)</label>
    <input id="guideName" type="text">
  </div>

  <div class="card">
    <label>Qty</label>
    <input id="qty" type="number" min="1" value="1">

    <label>Discount %</label>
    <input id="discountPercent" type="number">

    <label>Discount THB</label>
    <input id="discountAmount" type="number">
  </div>

  <div class="card">
    <strong style="font-size:13px;">Add Menu Item</strong><br><br>

    <label>Name (Line 1: English, Line 2: Korean)</label>
    <textarea id="menuName" rows="2" placeholder="English name&#10;Korean name" style="resize: none; font-size: 14px;"></textarea>

    <label>Price (THB)</label>
    <input id="menuPrice" type="number">

    <br>
    <button onclick="addManualMenuItem()">Add / Save to Menu</button>
  </div>

  <div class="card">
    <label>Bill Items</label>
    <table id="billTable">
      <thead><tr><th>Item</th><th>Qty</th><th>Total</th><th></th></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <button class="primary" onclick="printBill()">Print</button>
  <button onclick="clearBill()">Clear Bill</button>
  <button onclick="showDiscountPopup()">Discount</button>
  <button class="secondary" type="button" onclick="showAdminPopup()">Admin</button>

</div>

<!-- Custom context menu for tables -->
<div id="tableContextMenu">
  <div class="menu-item" data-action="copy">Copy Table</div>
  <div class="menu-item" data-action="paste">Paste Table</div>
  <div class="menu-item" data-action="makeAvailable">Change Status (Clear Table)</div>
  <div class="menu-item" data-action="split">Divide Table</div>
  <div class="menu-item" data-action="revertSplit">Revert Divide</div>
  <div class="menu-item" data-action="convertSplit">Convert Split Tables</div>
  <div class="menu-item" data-action="rename">Rename Table</div>
  <div class="menu-item" data-action="resize">Resize Table</div>
  <div class="menu-item" data-action="selectAll">Select All Tables</div>
  <div class="menu-item" data-action="equalSize">Make All Equal Size</div>
  <div class="menu-item" data-action="resizeSelected">Resize Selected Tables</div>
  <div class="menu-item" data-action="equalSizeSelected">Make Selected Equal Size</div>
  <div class="menu-item" data-action="delete">Delete Table</div>
</div>

<!-- Menu Popup -->
<div id="menuPopup" onclick="closeMenuPopup()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
  <div id="menuGridContainer" onclick="event.stopPropagation()" style="background: white; padding: 20px; border-radius: 10px; max-width: 600px; max-height: 80vh; overflow-y: auto;">
    <div class="menu-popup-header">
      <div class="table-title">Menu for <span id="popupTableName"></span></div>
    </div>
    <div class="menu-grid" id="menuGrid"></div>
    <div style="margin-top: 16px; display: flex; justify-content: center; gap: 12px;">
      <button type="button" onclick="event.stopPropagation(); closeMenuPopup()" style="background: #4CAF50; color: white; padding: 14px 48px; font-size: 18px; font-weight: bold; border: none; border-radius: 8px; cursor: pointer;">
        ‚úì OK
      </button>
      <button type="button" onclick="event.stopPropagation(); payTable(currentTable)" style="background: #1976d2; color: white; padding: 14px 48px; font-size: 18px; font-weight: bold; border: none; border-radius: 8px; cursor: pointer;">
        üíµ Pay
      </button>
    </div>
  </div>
</div>

<!-- Receipt Preview Popup -->
<div id="receiptPopup" onclick="closeReceiptPopup()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
  <div onclick="event.stopPropagation()" style="background: white; padding: 20px; border-radius: 10px; max-width: 400px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center;">
      <div class="table-title">Bill Preview</div>
      <button onclick="event.stopPropagation(); closeReceiptPopup()">Close</button>
    </div>
    <div id="receiptPreview" style="font-family: 'Consolas','Courier New',monospace; font-size: 12px; line-height: 1.2; white-space: pre; margin-top: 10px;"></div>
    <button onclick="printBill()" style="margin-top: 10px;">Print Bill</button>
    <button onclick="printSplitPayment()" style="margin-top: 10px;">Split Payment</button>
    <button onclick="printSelectiveMultiTablePayment()" style="margin-top: 10px;">Selective Pay (Multi-table)</button>
  </div>
</div>

<!-- Admin Popup (embed admin pages) -->
<div id="adminPopup" onclick="closeAdminPopup()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1100; justify-content: center; align-items: center;">
  <div class="admin-dialog" onclick="event.stopPropagation()">
    <div class="modal-header" style="padding: 12px 14px; border-bottom: 1px solid #e5e7eb;">
      <div class="table-title">Admin</div>
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end;">
        <button type="button" onclick="event.stopPropagation(); openAdminPage('/customers.html')">Customers</button>
        <button type="button" onclick="event.stopPropagation(); openAdminPage('/companies.html')">Companies</button>
        <button type="button" onclick="event.stopPropagation(); openAdminPage('/menu.html')">Menu</button>
        <button type="button" onclick="event.stopPropagation(); openAdminPage('/reservations.html')">Reservations</button>
        <button type="button" onclick="event.stopPropagation(); openAdminPage('/')">Home</button>
        <button type="button" onclick="event.stopPropagation(); closeAdminPopup()">Close</button>
      </div>
    </div>

    <div class="admin-body">
      <div class="admin-frame-wrap">
        <iframe id="adminFrame" class="admin-frame" title="Admin" src="/"></iframe>
      </div>
    </div>
  </div>
</div>

<!-- Reserved Slide-out Sidebar -->
<div id="reservedSidebarBackdrop" onclick="closeReservedSidebar()"></div>
<button id="reservedToggleBtn" type="button" onclick="toggleReservedSidebar()" aria-label="Open reserved sidebar">‚Ä∫</button>
<aside id="reservedSidebar" aria-label="Reserved bookings">
  <div class="reserved-header">
    <div>
      <div class="reserved-title">Reserved</div>
      <div class="reserved-sub" id="reservedSidebarSub">Today</div>
    </div>
    <div class="reserved-actions">
      <button id="reservedScopeBtn" type="button" onclick="toggleReservedScope()" title="Toggle between today and all dates">All Dates</button>
      <button type="button" onclick="refreshReservedSidebar()" title="Refresh">Refresh</button>
      <button type="button" onclick="closeReservedSidebar()">Close</button>
    </div>
  </div>
  <div class="reserved-body">
    <div class="reserved-section">
      <div class="reserved-section-title">Reservations</div>
      <div id="reservedReservations"></div>
    </div>
    <div class="reserved-section">
      <div class="reserved-section-title">Bookings</div>
      <div id="reservedBookings"></div>
    </div>
  </div>
</aside>

<!-- Reservation Modal -->
<div id="reservationPopup" class="modal-backdrop" onclick="closeReservationPopup()">
  <div class="modal-dialog reservation-dialog" onclick="event.stopPropagation()">
    <div class="modal-header">
      <div class="table-title">Reserve Table <span id="reserveTableName"></span></div>
      <button onclick="event.stopPropagation(); closeReservationPopup()">Close</button>
    </div>

    <button id="reservationPrevBtn" class="reservation-prev" type="button" aria-label="Back">‚Äπ</button>
    <button id="reservationNextBtn" class="reservation-next" type="button" aria-label="Next">‚Ä∫</button>

    <form id="reservationForm" class="modal-form">
      <div id="reservationSlider" class="reservation-slider">
        <div id="reservationTrack" class="reservation-track">
          <div class="reservation-slide">
            <div class="form-field full">
              <label>Date</label>
              <input type="date" id="reserveDate" class="visually-hidden" list="reserveDateList">

              <div id="reserveCalendar" class="cal">
                <div class="cal-header">
                  <button type="button" class="cal-nav" id="reserveCalPrev" aria-label="Previous month">‚Äπ</button>
                  <div id="reserveCalLabel" class="cal-label"></div>
                  <button type="button" class="cal-nav" id="reserveCalNext" aria-label="Next month">‚Ä∫</button>
                </div>
                <div class="cal-weekdays" aria-hidden="true">
                  <div>Sun</div><div>Mon</div><div>Tue</div><div>Wed</div><div>Thu</div><div>Fri</div><div>Sat</div>
                </div>
                <div id="reserveCalGrid" class="cal-grid" aria-label="Calendar"></div>
              </div>
            </div>
          </div>

          <div class="reservation-slide">
            <div class="form-field full">
              <label>Time (ETA)</label>
              <div class="field-wrap">
                <input type="time" id="reserveTime" step="600" list="reserveTimeList">
                <button type="button" class="field-icon-btn" id="reserveTimePickerBtn" aria-label="Open time picker">üïí</button>
              </div>
              <div id="reserveTimeGrid" class="time-grid" aria-label="Time options"></div>
            </div>
          </div>

          <div class="reservation-slide">
            <div class="form-field full">
              <label>Pax</label>
              <input type="number" id="reservePax" min="1" inputmode="numeric" list="reservePaxList">
              <div id="reservePaxPad" class="num-pad" aria-label="Number pad"></div>
              <div style="margin-top: 12px; width: 100%; max-width: 320px; display: flex; justify-content: center;">
                <button type="button" id="reservePaxConfirmBtn" class="pax-confirm">Confirm</button>
              </div>
            </div>
          </div>

          <div class="reservation-slide">
            <div class="form-field full">
              <label>Menu Item (optional)</label>
              <input type="text" id="reserveMenu" placeholder="Select or type" list="reserveMenuList">
            </div>
          </div>

          <div class="reservation-slide">
            <div class="form-field full">
              <label>Company (optional)</label>
              <input type="text" id="reserveCompany" placeholder="Select or type" list="reserveCompanyList">
            </div>
          </div>

          <div class="reservation-slide">
            <div class="form-field full">
              <label>Customer</label>
              <input type="text" id="reserveName" placeholder="Select or type" list="reserveCustomerList">
            </div>
          </div>

          <div class="reservation-slide">
            <div class="form-field full">
              <label>Phone (optional)</label>
              <input type="text" id="reservePhone" list="reservePhoneList" placeholder="Select or type">

              <div class="reservation-submit-wrap">
                <button id="reservationSubmitBtn" type="submit" class="primary">Reserve</button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <datalist id="reserveMenuList"></datalist>
      <datalist id="reserveCompanyList"></datalist>
      <datalist id="reserveCustomerList"></datalist>
      <datalist id="reservePhoneList"></datalist>
      <datalist id="reserveTimeList"></datalist>
      <datalist id="reservePaxList"></datalist>
      <datalist id="reserveDateList"></datalist>
    </form>
  </div>
</div>

<!-- Reservation Wizard (one modal per field) -->
<div id="reservationDateModal" class="modal-backdrop" onclick="closeReservationWizard()">
  <div class="modal-dialog reservation-dialog" onclick="event.stopPropagation()">
    <div class="modal-header">
      <div class="table-title">Reservation ‚Äî Date <span id="resWizTableLabel1"></span></div>
      <button type="button" onclick="closeReservationWizard()">Close</button>
    </div>
    <div class="modal-form" style="flex:1; display:flex; align-items:center; justify-content:center;">
      <div class="form-field full">
        <label>Date</label>
        <input type="date" id="resWizDate" class="visually-hidden" list="reserveDateList">

        <div id="resWizCompanySuggest" class="suggest-grid" aria-label="Company suggestions"></div>

        <div class="cal">
          <div class="cal-header">
            <button type="button" class="cal-nav" id="resWizCalPrev" aria-label="Previous month">‚Äπ</button>
            <div id="resWizCalLabel" class="cal-label"></div>
            <button type="button" class="cal-nav" id="resWizCalNext" aria-label="Next month">‚Ä∫</button>
          </div>
          <div class="cal-weekdays" aria-hidden="true">
            <div>Sun</div><div>Mon</div><div>Tue</div><div>Wed</div><div>Thu</div><div>Fri</div><div>Sat</div>
          </div>
          <div id="resWizCalGrid" class="cal-grid" aria-label="Calendar"></div>
        </div>

        <div class="reservation-submit-wrap" style="margin-top:16px;">
          <button type="button" onclick="closeReservationWizard()">Cancel</button>
          <button type="button" class="primary" onclick="reservationWizardNext('date')">Next</button>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="reservationTimeModal" class="modal-backdrop" onclick="closeReservationWizard()">
  <div class="modal-dialog reservation-dialog" onclick="event.stopPropagation()">
    <div class="modal-header">
      <div class="table-title">Reservation ‚Äî Time <span id="resWizTableLabel2"></span></div>
      <button type="button" onclick="closeReservationWizard()">Close</button>
    </div>
    <div class="modal-form" style="flex:1; display:flex; align-items:center; justify-content:center;">
      <div class="form-field full">
        <label>Time (ETA)</label>
        <div class="field-wrap">

        <div id="resWizCustomerSuggest" class="suggest-grid" aria-label="Customer suggestions"></div>
          <input type="time" id="resWizTime" step="600" list="reserveTimeList">
          <button type="button" class="field-icon-btn" id="resWizTimePickerBtn" aria-label="Open time picker">üïí</button>
        </div>
        <div id="resWizTimeGrid" class="time-grid" aria-label="Time options"></div>

        <div class="reservation-submit-wrap" style="margin-top:16px;">
          <button type="button" onclick="reservationWizardBack('time')">Back</button>
          <button type="button" class="primary" onclick="reservationWizardNext('time')">Next</button>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="reservationPaxModal" class="modal-backdrop" onclick="closeReservationWizard()">
  <div class="modal-dialog reservation-dialog" onclick="event.stopPropagation()">
    <div class="modal-header">
      <div class="table-title">Reservation ‚Äî Pax <span id="resWizTableLabel3"></span></div>
      <button type="button" onclick="closeReservationWizard()">Close</button>
    </div>
    <div class="modal-form" style="flex:1; display:flex; align-items:center; justify-content:center;">
      <div class="form-field full">
        <label>Pax</label>
        <input type="number" id="resWizPax" min="1" inputmode="numeric" list="reservePaxList">
        <div id="resWizPaxPad" class="num-pad" aria-label="Number pad"></div>
        <div style="margin-top: 12px; width: 100%; max-width: 320px; display: flex; justify-content: center;">
          <button type="button" class="pax-confirm" onclick="reservationWizardConfirmPax()">Confirm</button>
        </div>
        <div class="reservation-submit-wrap" style="margin-top:16px;">
          <button type="button" onclick="reservationWizardBack('pax')">Back</button>
          <button type="button" class="primary" onclick="reservationWizardNext('pax')">Next</button>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="reservationMenuModal" class="modal-backdrop" onclick="closeReservationWizard()">
  <div class="modal-dialog reservation-dialog" onclick="event.stopPropagation()">
    <div class="modal-header">
      <div class="table-title">Reservation ‚Äî Menu <span id="resWizTableLabel4"></span></div>
      <button type="button" onclick="closeReservationWizard()">Close</button>
    </div>
    <div class="modal-form" style="flex:1; display:flex; align-items:center; justify-content:center;">
      <div class="form-field full">
        <label>Menu Item (optional)</label>
        <div style="display: flex; gap: 8px; align-items: center;">
          <input type="text" id="resWizMenu" placeholder="Select or type" list="reserveMenuList" style="flex: 1;">
          <button type="button" onclick="showQuickAddMenuPopup()" style="white-space: nowrap; padding: 8px 12px;">+ Add</button>
        </div>
        <div class="reservation-submit-wrap" style="margin-top:16px;">
          <button type="button" onclick="reservationWizardBack('menu')">Back</button>
          <button type="button" class="primary" onclick="reservationWizardNext('menu')">Next</button>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="reservationCompanyModal" class="modal-backdrop" onclick="closeReservationWizard()">
  <div class="modal-dialog reservation-dialog" onclick="event.stopPropagation()">
    <div class="modal-header">
      <div class="table-title">Reservation ‚Äî Company <span id="resWizTableLabel5"></span></div>
      <button type="button" onclick="closeReservationWizard()">Close</button>
    </div>
    <div class="modal-form" style="flex:1; display:flex; align-items:center; justify-content:center;">
      <div class="form-field full">
        <label>Company (optional)</label>
        <div style="display: flex; gap: 8px; align-items: center;">
          <select id="resWizCompany" style="flex: 1; font-size: 1.2rem; padding: 12px;"></select>
          <button type="button" onclick="showQuickAddCompanyPopup()" style="white-space: nowrap; padding: 8px 12px;">+ Add</button>
        </div>
        <div class="reservation-submit-wrap" style="margin-top:16px;">
          <button type="button" onclick="reservationWizardBack('company')">Back</button>
          <button type="button" class="primary" onclick="reservationWizardNext('company')">Next</button>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="reservationCustomerModal" class="modal-backdrop" onclick="closeReservationWizard()">
  <div class="modal-dialog reservation-dialog" onclick="event.stopPropagation()">
    <div class="modal-header">
      <div class="table-title">Reservation ‚Äî Customer <span id="resWizTableLabel6"></span></div>
      <button type="button" onclick="closeReservationWizard()">Close</button>
    </div>
    <div class="modal-form" style="flex:1; display:flex; align-items:center; justify-content:center;">
      <div class="form-field full">
        <label>Customer</label>
        <div style="display: flex; gap: 8px; align-items: center;">
          <select id="resWizName" style="flex: 1; font-size: 1.2rem; padding: 12px;"></select>
          <button type="button" onclick="showQuickAddCustomerPopup()" style="white-space: nowrap; padding: 8px 12px;">+ Add</button>
        </div>
        <div class="reservation-submit-wrap" style="margin-top:16px;">
          <button type="button" onclick="reservationWizardBack('customer')">Back</button>
          <button type="button" class="primary" onclick="reservationWizardNext('customer')">Next</button>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="reservationPhoneModal" class="modal-backdrop" onclick="closeReservationWizard()">
  <div class="modal-dialog reservation-dialog" onclick="event.stopPropagation()">
    <div class="modal-header">
      <div class="table-title">Reservation ‚Äî Phone <span id="resWizTableLabel7"></span></div>
      <button type="button" onclick="closeReservationWizard()">Close</button>
    </div>
    <div class="modal-form" style="flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; gap: 16px;">
      <div class="form-field full" style="width: 100%; max-width: 320px;">
        <label>Phone (optional)</label>
        <input type="tel" id="resWizPhone" placeholder="Enter phone number" readonly style="font-size: 1.5rem; text-align: center; padding: 12px;">
        <div class="numpad-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 12px;">
          <button type="button" class="numpad-btn" onclick="phoneNumpadPress('1')">1</button>
          <button type="button" class="numpad-btn" onclick="phoneNumpadPress('2')">2</button>
          <button type="button" class="numpad-btn" onclick="phoneNumpadPress('3')">3</button>
          <button type="button" class="numpad-btn" onclick="phoneNumpadPress('4')">4</button>
          <button type="button" class="numpad-btn" onclick="phoneNumpadPress('5')">5</button>
          <button type="button" class="numpad-btn" onclick="phoneNumpadPress('6')">6</button>
          <button type="button" class="numpad-btn" onclick="phoneNumpadPress('7')">7</button>
          <button type="button" class="numpad-btn" onclick="phoneNumpadPress('8')">8</button>
          <button type="button" class="numpad-btn" onclick="phoneNumpadPress('9')">9</button>
          <button type="button" class="numpad-btn" onclick="phoneNumpadClear()" style="background: #f44336; color: white;">C</button>
          <button type="button" class="numpad-btn" onclick="phoneNumpadPress('0')">0</button>
          <button type="button" class="numpad-btn" onclick="phoneNumpadBackspace()" style="background: #ff9800; color: white;">‚å´</button>
        </div>
        <div class="reservation-submit-wrap" style="margin-top:16px;">
          <button type="button" onclick="reservationWizardBack('phone')">Back</button>
          <button type="button" class="primary" onclick="reservationWizardFinish()">Save Reservation</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Quick Add Customer Popup -->
<div id="quickAddCustomerPopup" class="modal-backdrop" onclick="closeQuickAddCustomerPopup()" style="display:none; z-index: 1200;">
  <div class="modal-dialog" onclick="event.stopPropagation()" style="max-width: 400px;">
    <div class="modal-header">
      <div class="table-title">Add New Customer</div>
      <button type="button" onclick="closeQuickAddCustomerPopup()">Close</button>
    </div>
    <div class="modal-form">
      <div class="form-field full">
        <label>Customer Name *</label>
        <input type="text" id="quickCustomerName" required placeholder="Enter customer name">
      </div>
      <div class="form-field full">
        <label>Phone (optional)</label>
        <input type="text" id="quickCustomerPhone" placeholder="Enter phone number">
      </div>
      <div class="form-field full">
        <label>Email (optional)</label>
        <input type="email" id="quickCustomerEmail" placeholder="Enter email">
      </div>
      <div class="form-field full">
        <label>Notes (optional)</label>
        <textarea id="quickCustomerNotes" rows="2" placeholder="Any notes"></textarea>
      </div>
      <div class="form-actions">
        <button type="button" onclick="closeQuickAddCustomerPopup()">Cancel</button>
        <button type="button" class="primary" onclick="saveQuickCustomer()">Save Customer</button>
      </div>
    </div>
  </div>
</div>

<!-- Quick Add Company Popup -->
<div id="quickAddCompanyPopup" class="modal-backdrop" onclick="closeQuickAddCompanyPopup()" style="display:none; z-index: 1200;">
  <div class="modal-dialog" onclick="event.stopPropagation()" style="max-width: 400px;">
    <div class="modal-header">
      <div class="table-title">Add New Company</div>
      <button type="button" onclick="closeQuickAddCompanyPopup()">Close</button>
    </div>
    <div class="modal-form">
      <div class="form-field full">
        <label>Company Name *</label>
        <input type="text" id="quickCompanyName" required placeholder="Enter company name">
      </div>
      <div class="form-field full">
        <label>Contact Person (optional)</label>
        <input type="text" id="quickCompanyContact" placeholder="Contact person name">
      </div>
      <div class="form-field full">
        <label>Phone (optional)</label>
        <input type="text" id="quickCompanyPhone" placeholder="Enter phone number">
      </div>
      <div class="form-field full">
        <label>Tax ID (optional)</label>
        <input type="text" id="quickCompanyTaxId" placeholder="Tax ID">
      </div>
      <div class="form-field full">
        <label>Address (optional)</label>
        <textarea id="quickCompanyAddress" rows="2" placeholder="Company address"></textarea>
      </div>
      <div class="form-actions">
        <button type="button" onclick="closeQuickAddCompanyPopup()">Cancel</button>
        <button type="button" class="primary" onclick="saveQuickCompany()">Save Company</button>
      </div>
    </div>
  </div>
</div>

<!-- Quick Add Menu Popup -->
<div id="quickAddMenuPopup" class="modal-backdrop" onclick="closeQuickAddMenuPopup()" style="display:none; z-index: 1200;">
  <div class="modal-dialog" onclick="event.stopPropagation()" style="max-width: 400px;">
    <div class="modal-header">
      <div class="table-title">Add New Menu Item</div>
      <button type="button" onclick="closeQuickAddMenuPopup()">Close</button>
    </div>
    <div class="modal-form">
      <div class="form-field full">
        <label>Menu Name (English / Korean)</label>
        <textarea id="quickMenuName" rows="2" placeholder="Line 1: English name&#10;Line 2: Korean name (optional)"></textarea>
      </div>
      <div class="form-field full">
        <label>Price</label>
        <input type="number" id="quickMenuPrice" min="0" step="1" placeholder="Enter price">
      </div>
      <div class="form-actions">
        <button type="button" onclick="closeQuickAddMenuPopup()">Cancel</button>
        <button type="button" class="primary" onclick="saveQuickMenu()">Save Menu</button>
      </div>
    </div>
  </div>
</div>

<!-- Divide Table Modal -->
<div id="dividePopup" class="modal-backdrop" onclick="closeDividePopup()">
  <div class="modal-dialog" onclick="event.stopPropagation()">
    <div class="modal-header">
      <div class="table-title">Divide Table <span id="divideTableName"></span></div>
      <button onclick="event.stopPropagation(); closeDividePopup()">Close</button>
    </div>

    <form id="divideForm" class="modal-form">
      <div class="form-grid">
        <div class="form-field">
          <label>Sections</label>
          <input type="number" id="divideCount" min="1" max="6" required>
        </div>

        <div class="form-field">
          <label>Direction</label>
          <select id="divideDirection" required>
            <option value="v">Vertical (side-by-side)</option>
            <option value="h">Horizontal (stacked)</option>
          </select>
        </div>

        <div class="divide-preview">
          <div id="dividePreviewBox" class="divide-preview-box" aria-label="Divide preview"></div>
        </div>
      </div>

      <div class="form-actions">
        <button type="button" onclick="closeDividePopup()">Cancel</button>
        <button type="submit" class="primary">Apply</button>
      </div>
    </form>
  </div>
</div>

<!-- Walk-in vs Reservation Modal (with Pax input) -->
<div id="walkinReservationPopup" class="modal-backdrop" onclick="closeWalkInReservationPopup()">
  <div class="modal-dialog" onclick="event.stopPropagation()">
    <div class="modal-header">
      <div class="table-title">Choose for <span id="walkinReservationTableName"></span></div>
    </div>

    <div class="modal-form">
      <div class="form-field full">
        <label>Table is empty</label>
        <div style="font-size: 13px; color:#444;">Enter number of guests and select Walk-in or Reservation.</div>
      </div>

      <div style="margin-bottom: 16px;">
        <label style="font-weight: 600; margin-bottom: 6px; display: block;">Number of Guests (Pax)</label>
        <div style="display: flex; align-items: center; justify-content: center; gap: 16px;">
          <button type="button" onclick="adjustWalkInPax(-1)" style="width: 48px; height: 48px; font-size: 24px; font-weight: bold; border-radius: 8px;">‚àí</button>
          <input type="number" id="walkInPaxInput" min="1" max="999" placeholder="" style="width: 80px; height: 48px; font-size: 24px; text-align: center; border: 2px solid #ccc; border-radius: 8px;">
          <button type="button" onclick="adjustWalkInPax(1)" style="width: 48px; height: 48px; font-size: 24px; font-weight: bold; border-radius: 8px;">+</button>
        </div>
      </div>

      <div class="choice-grid">
        <button type="button" class="choice-btn primary" data-choice="walkin">
          <div>üö∂ Walk-in</div>
          <small>Open menu / start order</small>
        </button>
        <button type="button" class="choice-btn" data-choice="reservation">
          <div>üìÖ Reservation</div>
          <small>Create / edit booking</small>
        </button>
      </div>

      <div class="form-actions">
        <button type="button" onclick="closeWalkInReservationPopup()">Cancel</button>
      </div>
    </div>
  </div>
</div>

<!-- Action Choice Modal (replaces prompt/confirm for simple decisions) -->
<div id="actionPopup" class="modal-backdrop" onclick="closeActionPopup()" style="display:none;">
  <div class="modal-dialog" onclick="event.stopPropagation()">
    <div class="modal-header">
      <div class="table-title" id="actionTitle">Action</div>
    </div>

    <div class="modal-form">
      <div id="actionMessage" style="font-size: 13px; color:#444; white-space: pre-line;"></div>
      <div id="actionChoices" class="choice-grid auto"></div>

      <div class="form-actions">
        <button type="button" id="actionCancelBtn" onclick="closeActionPopup()">Cancel</button>
      </div>
    </div>
  </div>
</div>

<!-- Menu Item Quantity Popup (long press or right-click on menu item) -->
<div id="menuQtyPopup" class="modal-backdrop" onclick="closeMenuQtyPopup()" style="display:none;">
  <div class="modal-dialog" onclick="event.stopPropagation()" style="max-width: 320px;">
    <div class="modal-header">
      <div class="table-title" id="menuQtyTitle">Set Quantity</div>
      <button type="button" onclick="event.stopPropagation(); closeMenuQtyPopup()">Close</button>
    </div>

    <div class="modal-form">
      <div id="menuQtyItemName" style="font-size: 16px; font-weight: 600; color:#222; margin-bottom: 8px;"></div>
      <div id="menuQtyItemPrice" style="font-size: 14px; color:#666; margin-bottom: 16px;"></div>
      
      <div style="display: flex; align-items: center; justify-content: center; gap: 16px; margin-bottom: 16px;">
        <button type="button" id="menuQtyMinus" onclick="adjustMenuQty(-1)" style="width: 48px; height: 48px; font-size: 24px; font-weight: bold; border-radius: 8px;">‚àí</button>
        <input type="number" id="menuQtyInput" value="1" min="1" max="999" style="width: 80px; height: 48px; font-size: 24px; text-align: center; border: 2px solid #ccc; border-radius: 8px;">
        <button type="button" id="menuQtyPlus" onclick="adjustMenuQty(1)" style="width: 48px; height: 48px; font-size: 24px; font-weight: bold; border-radius: 8px;">+</button>
      </div>
      
      <div id="menuQtyTotal" style="font-size: 18px; font-weight: 700; color:#111; text-align: center; margin-bottom: 16px;">Total: 0 THB</div>

      <div class="form-actions" style="justify-content: center; gap: 12px;">
        <button type="button" onclick="closeMenuQtyPopup()">Cancel</button>
        <button type="button" class="primary" onclick="confirmMenuQty()">Add to Order</button>
      </div>
    </div>
  </div>
</div>

<!-- Bill Item Edit Popup (long press or right-click on bill item) -->
<div id="billItemEditPopup" class="modal-backdrop" onclick="closeBillItemEditPopup()" style="display:none;">
  <div class="modal-dialog" onclick="event.stopPropagation()" style="max-width: 340px;">
    <div class="modal-header">
      <div class="table-title">Edit Item</div>
      <button type="button" onclick="event.stopPropagation(); closeBillItemEditPopup()">Close</button>
    </div>

    <div class="modal-form">
      <div id="billItemEditName" style="font-size: 16px; font-weight: 600; color:#222; margin-bottom: 4px;"></div>
      <div id="billItemEditInfo" style="font-size: 13px; color:#666; margin-bottom: 16px;"></div>
      
      <label style="font-weight: 600; margin-bottom: 6px; display: block;">Remove Quantity</label>
      <div style="display: flex; align-items: center; justify-content: center; gap: 16px; margin-bottom: 16px;">
        <button type="button" onclick="adjustBillItemRemoveQty(-1)" style="width: 48px; height: 48px; font-size: 24px; font-weight: bold; border-radius: 8px;">‚àí</button>
        <input type="number" id="billItemRemoveQty" value="1" min="1" max="999" style="width: 80px; height: 48px; font-size: 24px; text-align: center; border: 2px solid #ccc; border-radius: 8px;">
        <button type="button" onclick="adjustBillItemRemoveQty(1)" style="width: 48px; height: 48px; font-size: 24px; font-weight: bold; border-radius: 8px;">+</button>
      </div>

      <div class="form-actions" style="flex-direction: column; gap: 10px;">
        <button type="button" class="primary" onclick="confirmBillItemRemove()" style="width: 100%;">Remove Selected Qty</button>
        <button type="button" class="danger" onclick="confirmBillItemRemoveAll()" style="width: 100%; background: #dc3545; color: white;">Remove All</button>
        <button type="button" onclick="closeBillItemEditPopup()" style="width: 100%;">Cancel</button>
      </div>
    </div>
  </div>
</div>

<!-- Discount Popup -->
<div id="discountPopup" class="modal-backdrop" onclick="closeDiscountPopup()" style="display:none;">
  <div class="modal-dialog" onclick="event.stopPropagation()" style="max-width: 360px;">
    <div class="modal-header">
      <div class="table-title">Apply Discount</div>
      <button type="button" onclick="event.stopPropagation(); closeDiscountPopup()">Close</button>
    </div>

    <div class="modal-form">
      <div id="discountSubtotalInfo" style="font-size: 14px; color:#444; margin-bottom: 16px;"></div>
      
      <div style="margin-bottom: 16px;">
        <label style="font-weight: 600; margin-bottom: 6px; display: block;">Discount by Percentage (%)</label>
        <div style="display: flex; align-items: center; gap: 8px;">
          <input type="number" id="discountPopupPercent" value="0" min="0" max="100" step="1" style="flex: 1; height: 44px; font-size: 18px; text-align: center; border: 2px solid #ccc; border-radius: 8px;">
          <span style="font-size: 18px; font-weight: bold;">%</span>
        </div>
        <div style="display: flex; gap: 6px; margin-top: 8px; flex-wrap: wrap;">
          <button type="button" onclick="setDiscountPercent(5)" style="padding: 8px 12px; border-radius: 6px;">5%</button>
          <button type="button" onclick="setDiscountPercent(10)" style="padding: 8px 12px; border-radius: 6px;">10%</button>
          <button type="button" onclick="setDiscountPercent(15)" style="padding: 8px 12px; border-radius: 6px;">15%</button>
          <button type="button" onclick="setDiscountPercent(20)" style="padding: 8px 12px; border-radius: 6px;">20%</button>
          <button type="button" onclick="setDiscountPercent(25)" style="padding: 8px 12px; border-radius: 6px;">25%</button>
          <button type="button" onclick="setDiscountPercent(50)" style="padding: 8px 12px; border-radius: 6px;">50%</button>
        </div>
      </div>
      
      <div style="text-align: center; font-weight: 600; color:#888; margin-bottom: 16px;">‚Äî OR ‚Äî</div>
      
      <div style="margin-bottom: 16px;">
        <label style="font-weight: 600; margin-bottom: 6px; display: block;">Discount by Amount (THB)</label>
        <div style="display: flex; align-items: center; gap: 8px;">
          <input type="number" id="discountPopupAmount" value="0" min="0" step="1" style="flex: 1; height: 44px; font-size: 18px; text-align: center; border: 2px solid #ccc; border-radius: 8px;">
          <span style="font-size: 18px; font-weight: bold;">THB</span>
        </div>
        <div style="display: flex; gap: 6px; margin-top: 8px; flex-wrap: wrap;">
          <button type="button" onclick="setDiscountAmount(50)" style="padding: 8px 12px; border-radius: 6px;">50</button>
          <button type="button" onclick="setDiscountAmount(100)" style="padding: 8px 12px; border-radius: 6px;">100</button>
          <button type="button" onclick="setDiscountAmount(200)" style="padding: 8px 12px; border-radius: 6px;">200</button>
          <button type="button" onclick="setDiscountAmount(500)" style="padding: 8px 12px; border-radius: 6px;">500</button>
          <button type="button" onclick="setDiscountAmount(1000)" style="padding: 8px 12px; border-radius: 6px;">1000</button>
        </div>
      </div>
      
      <div id="discountPreview" style="font-size: 16px; font-weight: 700; color:#111; text-align: center; padding: 12px; background: #f0f0f0; border-radius: 8px; margin-bottom: 16px;"></div>

      <div class="form-actions" style="justify-content: center; gap: 12px;">
        <button type="button" onclick="clearDiscountPopup()" style="background: #f8d7da; color: #721c24;">Clear Discount</button>
        <button type="button" class="primary" onclick="applyDiscountPopup()">Apply Discount</button>
      </div>
    </div>
  </div>
</div>

<!-- Payment Modal -->
<div id="paymentModal" class="modal-backdrop" onclick="closePaymentModal()" style="display:none;">
  <div class="modal-dialog" onclick="event.stopPropagation()" style="max-width: 420px; position: relative;">
    <div class="modal-header" style="padding: 8px 12px; display: flex; align-items: center; justify-content: space-between;">
      <div style="display: flex; align-items: center; gap: 10px;">
        <div class="table-title" style="font-size: 16px;">Payment ‚Äî <span id="paymentTableName"></span></div>
        <button id="receiptPreviewBtn" title="Preview Receipt" onclick="event.stopPropagation(); openReceiptPreviewPanel()" style="background: none; border: none; cursor: pointer; font-size: 18px; margin-left: 6px; color: #1976d2;">
          üßæ
        </button>
      </div>
      <button type="button" onclick="event.stopPropagation(); closePaymentModal()" style="padding: 4px 10px;">Close</button>
    </div>
<!-- Receipt Preview Side Panel -->
<div id="receiptPreviewPanel" style="display:none; position:fixed; top:0; right:0; height:100vh; width: min(420px, 96vw); background:#fff; z-index:2000; box-shadow: -8px 0 24px rgba(0,0,0,0.18); transition: transform 0.18s; transform: translateX(100%); flex-direction:column;">
  <div style="display:flex; align-items:center; justify-content:space-between; padding:12px 16px; border-bottom:1px solid #eee;">
    <div style="font-size:18px; font-weight:700; color:#1976d2;">Receipt Preview</div>
    <button onclick="closeReceiptPreviewPanel()" style="font-size:20px; background:none; border:none; cursor:pointer;">‚úï</button>
  </div>
  <div style="flex:1; overflow-y:auto; padding: 12px;">
    <div id="receiptPreviewContent"></div>
  </div>
  <div style="padding: 12px; border-top: 1px solid #eee; display: flex; justify-content: flex-end;">
    <button onclick="printReceiptPreview()" style="background: #1976d2; color: #fff; font-size: 15px; font-weight: 600; border: none; border-radius: 6px; padding: 10px 18px; cursor: pointer;">Print</button>
  </div>
</div>
<script>
function openReceiptPreviewPanel() {
  updateReceiptPreview();
  document.getElementById('receiptPreviewContent').innerHTML = document.getElementById('receipt-area')?.innerHTML || '';
  const panel = document.getElementById('receiptPreviewPanel');
  panel.style.display = 'flex';
  setTimeout(() => { panel.style.transform = 'translateX(0)'; }, 10);
}
function closeReceiptPreviewPanel() {
  const panel = document.getElementById('receiptPreviewPanel');
  panel.style.transform = 'translateX(100%)';
  setTimeout(() => { panel.style.display = 'none'; }, 180);
}
function printReceiptPreview() {
  // Print only the receipt preview content, do not clear the bill
  const printContents = document.getElementById('receiptPreviewContent').innerHTML;
  const win = window.open('', '', 'width=420,height=600');
  win.document.write('<html><head><title>Receipt Preview</title>');
  win.document.write('<style>body{margin:0;padding:0;}#receipt-area{width:72mm;margin:0 auto;}</style>');
  win.document.write('</head><body>');
  win.document.write(printContents);
  win.document.write('</body></html>');
  win.document.close();
  win.focus();
  setTimeout(() => { win.print(); win.close(); }, 300);
}
</script>

    <div class="modal-form" style="padding: 10px;">
      <!-- Tax Invoice Toggle + Bill Summary Combined -->
      <div style="background: #f5f5f5; border-radius: 6px; padding: 8px 10px; margin-bottom: 8px;">
        <div style="display: flex; justify-content: space-between; align-items: center; padding-bottom: 6px; margin-bottom: 6px; border-bottom: 1px solid #ddd;">
          <div style="display: flex; gap: 10px; font-size: 12px; flex-wrap: wrap;">
            <span>Sub<small>(VAT incl.)</small>: <b id="paymentSubtotal">0</b></span>
            <span style="color: #d32f2f;">Disc: <b id="paymentDiscount">0</b> <button type="button" onclick="event.stopPropagation(); openDiscountFromPayment()" style="font-size: 9px; padding: 1px 4px;">Edit</button></span>
          </div>
          <label style="display: flex; align-items: center; gap: 4px; font-size: 11px; cursor: pointer;">
            üßæ Tax Invoice
            <input type="checkbox" id="taxInvoiceToggle" onchange="updatePaymentModal()" style="width: 16px; height: 16px;">
          </label>
        </div>
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <span style="font-size: 16px; font-weight: 700;">TOTAL:</span>
          <span id="paymentTotal" style="font-size: 20px; font-weight: 700; color: #1976d2;">0 ‡∏ø</span>
        </div>
        <div id="taxInvoiceNote" style="display: none; font-size: 10px; color: #666; margin-top: 4px; text-align: right;">+7% VAT for Tax Invoice</div>
      </div>

      <!-- Currency Payment Inputs (tap to select, use numpad) -->
      <div style="background: #e3f2fd; border-radius: 6px; padding: 8px; margin-bottom: 8px;">
        <div style="font-weight: 600; margin-bottom: 6px; font-size: 12px; color: #1565c0;">üíµ Tap currency, use numpad:</div>
        
        <!-- Baht Display -->
        <div id="payBahtRow" onclick="selectPaymentCurrency('baht')" 
             style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px; padding: 6px 8px; background: #fff; border-radius: 6px; border: 2px solid #1976d2; cursor: pointer;">
          <span style="width: 55px; font-weight: 600; font-size: 13px;">üáπüá≠ Baht</span>
          <span id="payBahtDisplay" style="flex: 1; font-size: 18px; font-weight: 700; text-align: right;">0</span>
          <span style="font-size: 14px;">‡∏ø</span>
        </div>
        <input type="hidden" id="payBahtInput" value="0">
        
        <!-- Dollar Display -->
        <div id="payDollarRow" onclick="selectPaymentCurrency('dollar')" 
             style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px; padding: 6px 8px; background: #fff; border-radius: 6px; border: 2px solid transparent; cursor: pointer;">
          <span style="width: 55px; font-weight: 600; font-size: 13px;">üá∫üá∏ USD</span>
          <span id="payDollarDisplay" style="flex: 1; font-size: 18px; font-weight: 700; text-align: right;">0</span>
          <span style="font-size: 14px;">$</span>
        </div>
        <input type="hidden" id="payDollarInput" value="0">
        
        <!-- Won Display -->
        <div id="payWonRow" onclick="selectPaymentCurrency('won')" 
             style="display: flex; align-items: center; gap: 8px; padding: 6px 8px; background: #fff; border-radius: 6px; border: 2px solid transparent; cursor: pointer;">
          <span style="width: 55px; font-weight: 600; font-size: 13px;">üá∞üá∑ Won</span>
          <span id="payWonDisplay" style="flex: 1; font-size: 18px; font-weight: 700; text-align: right;">0</span>
          <span style="font-size: 14px;">‚Ç©</span>
        </div>
        <input type="hidden" id="payWonInput" value="0">
      </div>

      <!-- Number Pad -->
      <div style="background: #f5f5f5; border-radius: 6px; padding: 6px; margin-bottom: 8px;">
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px;">
          <button type="button" onclick="payNumpadPress('1')" style="height: 42px; font-size: 20px; font-weight: 700;">1</button>
          <button type="button" onclick="payNumpadPress('2')" style="height: 42px; font-size: 20px; font-weight: 700;">2</button>
          <button type="button" onclick="payNumpadPress('3')" style="height: 42px; font-size: 20px; font-weight: 700;">3</button>
          <button type="button" onclick="payNumpadPress('backspace')" style="height: 42px; font-size: 16px; background: #ffcdd2;">‚å´</button>
          
          <button type="button" onclick="payNumpadPress('4')" style="height: 42px; font-size: 20px; font-weight: 700;">4</button>
          <button type="button" onclick="payNumpadPress('5')" style="height: 42px; font-size: 20px; font-weight: 700;">5</button>
          <button type="button" onclick="payNumpadPress('6')" style="height: 42px; font-size: 20px; font-weight: 700;">6</button>
          <button type="button" onclick="payNumpadPress('clear')" style="height: 42px; font-size: 12px; background: #ffcdd2;">CLR</button>
          
          <button type="button" onclick="payNumpadPress('7')" style="height: 42px; font-size: 20px; font-weight: 700;">7</button>
          <button type="button" onclick="payNumpadPress('8')" style="height: 42px; font-size: 20px; font-weight: 700;">8</button>
          <button type="button" onclick="payNumpadPress('9')" style="height: 42px; font-size: 20px; font-weight: 700;">9</button>
          <button type="button" onclick="payNumpadPress('exact')" style="height: 42px; font-size: 11px; background: #c8e6c9;">EXACT</button>
          
          <button type="button" onclick="payNumpadPress('00')" style="height: 42px; font-size: 18px; font-weight: 700;">00</button>
          <button type="button" onclick="payNumpadPress('0')" style="height: 42px; font-size: 20px; font-weight: 700;">0</button>
          <button type="button" onclick="payNumpadPress('.')" style="height: 42px; font-size: 20px; font-weight: 700;">.</button>
          <button type="button" onclick="payNumpadPress('000')" style="height: 42px; font-size: 16px; font-weight: 700;">000</button>
        </div>
      </div>

      <!-- Remaining Balance Display -->
      <div id="paymentRemainingSection" style="background: #ffebee; border-radius: 6px; padding: 8px 10px; margin-bottom: 8px;">
        <div style="font-weight: 600; font-size: 12px; color: #c62828; margin-bottom: 4px;">üìä Remaining:</div>
        <div style="display: flex; justify-content: space-between; font-size: 13px;">
          <span>üáπüá≠ <b id="remainingBaht">0 ‡∏ø</b></span>
          <span>üá∫üá∏ <b id="remainingDollar">$0</b></span>
          <span>üá∞üá∑ <b id="remainingWon">‚Ç©0</b></span>
        </div>
      </div>

      <!-- Overpayment / Change Display -->
      <div id="paymentChangeSection" style="background: #e8f5e9; border-radius: 6px; padding: 8px 10px; margin-bottom: 8px; display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <span style="font-size: 14px; font-weight: 700; color: #2e7d32;">üí∞ Change:</span>
          <span id="changeAmount" style="font-size: 20px; font-weight: 700; color: #2e7d32;">0 ‡∏ø</span>
        </div>
      </div>

      <!-- Exchange Rate Info + Payment Actions -->
      <div style="font-size: 10px; color: #666; text-align: center; margin-bottom: 6px;">
        1 USD = <span id="rateUsdToBaht">34.48</span> ‡∏ø | 1000 ‚Ç© = <span id="rateWonToBaht">25.32</span> ‡∏ø
      </div>

      <div style="display: flex; gap: 8px;">
        <button type="button" onclick="closePaymentModal()" style="flex: 1; padding: 10px; font-size: 14px;">Cancel</button>
        <button type="button" id="confirmPaymentBtn" class="primary" onclick="confirmPayment()" style="flex: 2; padding: 10px; font-size: 16px; font-weight: 700; background: #4CAF50;" disabled>
          ‚úì Confirm Payment
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Merge Sections Modal (click to select sections instead of typing) -->
<div id="mergePartsPopup" class="modal-backdrop" onclick="closeMergePartsPopup()" style="display:none;">
  <div class="modal-dialog" onclick="event.stopPropagation()">
    <div class="modal-header">
      <div class="table-title">Merge Sections <span id="mergePartsTableName"></span></div>
      <button type="button" onclick="event.stopPropagation(); closeMergePartsPopup()">Close</button>
    </div>

    <div class="modal-form">
      <div class="form-field full">
        <label>Select 2 or more sections</label>
        <div style="font-size: 13px; color:#444;">Tap the sections you want to merge into one.</div>
      </div>

      <div id="mergePartsGrid" class="choice-grid" style="grid-template-columns: 1fr 1fr 1fr;"></div>

      <div class="form-actions">
        <button type="button" onclick="closeMergePartsPopup()">Cancel</button>
        <button type="button" id="mergePartsConfirmBtn" class="primary" disabled>Merge Selected</button>
      </div>
    </div>
  </div>
</div>

<!-- ============================
     PART 2 ‚Äî TABLE + MENU + BILL
     ============================ -->
<script>

/* ==========================================================
   PART 2 ‚Äî TABLE SYSTEM + MENU CLICK ENGINE + BILL RENDERING
   ========================================================== */

/* --------------------------------------------------
   STORAGE FOR TABLE ORDERS & POSITIONS
-------------------------------------------------- */
let orders = {};        // { "17A": [...], "7B": [...] }
let currentTable = null;
let currentTablePart = 1; // 1..N when a table is divided
let reservations = {};  // { "17A": {name, phone, date, time, guests} }

/* Load table orders from localStorage (backend will override if available) */
(function loadOrdersFromStorage() {
  const saved = localStorage.getItem("orders");
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      if (parsed && typeof parsed === "object" && !Array.isArray(parsed)) orders = parsed;
    } catch (e) {
      orders = {};
    }
  }
})();

// Manually mark a table as occupied (e.g., reservation has arrived) even if no items yet.
let tableOccupiedOverrides = {}; // { "17A": true, ... }

// Table needs cleaning (paid, no outstanding bill)
let tableNeedsCleaning = {}; // { "17A": true, ... }

// Pax count per table (for default quantity when adding items)
let tablePaxCount = {}; // { "17A": 4, ... }

function getTablePax(tableName) {
  return tablePaxCount[tableName] || 1;
}

function setTablePax(tableName, pax) {
  tablePaxCount[tableName] = Math.max(1, pax || 1);
}

function clearTablePax(tableName) {
  delete tablePaxCount[tableName];
}

function isTableOccupiedOverride(name) {
  return !!tableOccupiedOverrides[name];
}

function isTableNeedsCleaning(name) {
  return !!tableNeedsCleaning[name];
}

function setTableOccupiedOverride(name, occupied) {
  if (occupied) tableOccupiedOverrides[name] = true;
  else {
    delete tableOccupiedOverrides[name];
    // If it is no longer occupied, it can't be "needs cleaning".
    delete tableNeedsCleaning[name];
    saveTableNeedsCleaning();
  }
  saveTableOccupiedOverrides();
}

function setTableNeedsCleaning(name, needsCleaning) {
  if (needsCleaning) {
    tableNeedsCleaning[name] = true;
    // Needs cleaning implies the table is still occupied until staff cleans it.
    tableOccupiedOverrides[name] = true;
    saveTableOccupiedOverrides();
  } else {
    delete tableNeedsCleaning[name];
  }
  saveTableNeedsCleaning();
}

// Mark a table as fully cleaned and available - clears all data
function markTableCleanedAndAvailable(tableName) {
  // Clear needs cleaning status
  setTableNeedsCleaning(tableName, false);
  
  // Clear occupied override
  setTableOccupiedOverride(tableName, false);
  
  // Clear any outstanding orders for all parts of this table
  const parts = getSplitCount(tableName);
  for (let p = 1; p <= Math.max(parts, 1); p++) {
    const list = getOrderList(tableName, p);
    if (list && list.length > 0) {
      list.length = 0;
    }
  }
  
  // Clear pax count
  clearTablePax(tableName);
  
  // Clear reservation if any
  delete reservations[tableName];
  
  // Update UI
  updateTableColors();
  saveOrders();
  
  console.log(`Table ${tableName} marked as cleaned and available`);
}

// Number of sub-sections per table (divide within the same table box)
let tableSplits = {};   // { "17A": 3, ... }
let tableSplitDirections = {}; // { "17A": "v"|"h" }

function getSplitCount(name) {
  const n = tableSplits[name];
  return (typeof n === 'number' && n >= 2) ? n : 1;
}

function getSplitDirection(name) {
  const d = tableSplitDirections[name];
  return (d === 'h' || d === 'v') ? d : 'v';
}

function isSplitTable(name) {
  return getSplitCount(name) > 1;
}

function ensureTableMemory(name) {
  if (!orders[name]) orders[name] = [];
  normalizeOrdersShape(name);
}

function normalizeOrdersShape(name) {
  const parts = getSplitCount(name);
  const current = orders[name];

  if (parts === 1) {
    // If this was previously split and is now merged, keep part 1.
    if (Array.isArray(current) && Array.isArray(current[0])) {
      orders[name] = current[0] || [];
    }
    if (!Array.isArray(orders[name])) orders[name] = [];
    return;
  }

  // Ensure array-of-arrays.
  if (!Array.isArray(current) || !Array.isArray(current[0])) {
    const base = Array.isArray(current) ? current : [];
    const byPart = [base];
    for (let i = 1; i < parts; i++) byPart.push([]);
    orders[name] = byPart;
    return;
  }

  // Resize parts array to match split count.
  while (orders[name].length < parts) orders[name].push([]);
  if (orders[name].length > parts) orders[name] = orders[name].slice(0, parts);
}

function getOrderList(name, part = 1) {
  ensureTableMemory(name);
  const parts = getSplitCount(name);
  const p = Math.max(1, Math.min(parts, part));

  if (parts === 1) return orders[name];
  if (!orders[name][p - 1]) orders[name][p - 1] = [];
  return orders[name][p - 1];
}

function tableHasAnyItems(name) {
  ensureTableMemory(name);
  const parts = getSplitCount(name);
  if (parts === 1) return orders[name].length > 0;
  return orders[name].some(p => Array.isArray(p) && p.length > 0);
}

function tableTotal(name) {
  ensureTableMemory(name);
  const parts = getSplitCount(name);
  if (parts === 1) return (orders[name] || []).reduce((sum, it) => sum + (it?.total ?? 0), 0);
  return orders[name].reduce((sum, part) => sum + (part || []).reduce((s, it) => s + (it?.total ?? 0), 0), 0);
}

function tablePartTotals(name) {
  ensureTableMemory(name);
  const parts = getSplitCount(name);
  if (parts === 1) return [tableTotal(name)];

  normalizeOrdersShape(name);
  const current = Array.isArray(orders[name]) ? orders[name] : [];
  const totals = [];
  for (let i = 0; i < parts; i++) {
    const list = Array.isArray(current[i]) ? current[i] : [];
    const t = list.reduce((s, it) => s + (it?.total ?? 0), 0);
    totals.push(t);
  }
  return totals;
}

function setActiveTable(name, part = 1) {
  currentTable = name;
  currentTablePart = Math.max(1, Math.min(getSplitCount(name), part));
  ensureTableMemory(name);
  items = getOrderList(name, currentTablePart);
}

let walkInReservationResolver = null;

let actionPopupResolver = null;
let actionPopupChoiceValues = [];

let mergePartsResolver = null;
let mergePartsSelected = new Set();

function closeWalkInReservationPopup() {
  const popup = document.getElementById('walkinReservationPopup');
  if (popup) popup.style.display = 'none';

  if (typeof walkInReservationResolver === 'function') {
    const resolve = walkInReservationResolver;
    walkInReservationResolver = null;
    resolve(null);
  }
}

function adjustWalkInPax(delta) {
  const input = document.getElementById('walkInPaxInput');
  if (!input) return;
  let val = parseInt(input.value || '0', 10);
  val = Math.max(1, Math.min(999, val + delta));
  input.value = val;
}

function promptWalkInOrReservation(tableName) {
  // Returns a Promise<{ choice: 'walkin'|'reservation', pax: number } | null>
  return new Promise((resolve) => {
    // If already open, cancel the previous request.
    if (typeof walkInReservationResolver === 'function') {
      const prev = walkInReservationResolver;
      walkInReservationResolver = null;
      try { prev(null); } catch (e) {}
    }

    const popup = document.getElementById('walkinReservationPopup');
    if (!popup) {
      // Fallback to old prompt if markup is missing.
      const choice = prompt(
        'Table "' + tableName + '" is empty.\n\n' +
        '1 = Walk-in\n' +
        '2 = Reservation\n\n' +
        'Enter 1 or 2:',
        '1'
      );
      if (choice === null) return resolve(null);
      const trimmed = String(choice).trim();
      if (trimmed === '1') return resolve({ choice: 'walkin', pax: 1 });
      if (trimmed === '2') return resolve({ choice: 'reservation', pax: 1 });
      alert('Invalid choice. Please enter 1 or 2.');
      return resolve(null);
    }

    const nameEl = document.getElementById('walkinReservationTableName');
    if (nameEl) nameEl.textContent = tableName;

    // Reset pax input
    const paxInput = document.getElementById('walkInPaxInput');
    if (paxInput) paxInput.value = '';

    walkInReservationResolver = resolve;
    popup.style.display = 'flex';

    // Bind buttons once
    if (!popup.dataset.bound) {
      const dialog = popup.querySelector('.modal-dialog');
      (dialog || popup).addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-choice]');
        if (!btn) return;
        const choice = btn.dataset.choice;
        const paxInput = document.getElementById('walkInPaxInput');
        const pax = Math.max(1, parseInt(paxInput?.value || '1', 10));
        const res = (choice === 'reservation') ? 'reservation' : 'walkin';
        popup.style.display = 'none';
        const r = walkInReservationResolver;
        walkInReservationResolver = null;
        if (typeof r === 'function') r({ choice: res, pax: pax });
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          const p = document.getElementById('walkinReservationPopup');
          if (p && p.style.display === 'flex') closeWalkInReservationPopup();
        }
      });

      popup.dataset.bound = '1';
    }

    // Focus the pax input first
    if (paxInput) paxInput.focus();
  });
}

function closeActionPopup() {
  const popup = document.getElementById('actionPopup');
  if (popup) popup.style.display = 'none';

  if (typeof actionPopupResolver === 'function') {
    const resolve = actionPopupResolver;
    actionPopupResolver = null;
    actionPopupChoiceValues = [];
    resolve(null);
  }
}

function closeMergePartsPopup() {
  const popup = document.getElementById('mergePartsPopup');
  if (popup) popup.style.display = 'none';

  if (typeof mergePartsResolver === 'function') {
    const resolve = mergePartsResolver;
    mergePartsResolver = null;
    mergePartsSelected = new Set();
    resolve(null);
  }
}

function promptMergeParts({ tableName, partsCount } = {}) {
  // Returns a Promise<number[]|null>
  return new Promise((resolve) => {
    const popup = document.getElementById('mergePartsPopup');
    if (!popup) {
      // Fallback to old prompt if markup is missing.
      const raw = prompt(
        'Enter the section numbers to merge (e.g. 1,3).\n\n' +
        'Current sections: 1-' + partsCount,
        '1,3'
      );
      if (raw === null) return resolve(null);
      const nums = String(raw).match(/\d+/g) || [];
      const picked = nums.map(n => parseInt(n, 10)).filter(n => Number.isFinite(n));
      return resolve(picked);
    }

    // Cancel any existing merge prompt.
    if (typeof mergePartsResolver === 'function') {
      const prev = mergePartsResolver;
      mergePartsResolver = null;
      mergePartsSelected = new Set();
      try { prev(null); } catch (e) {}
    }

    const nameEl = document.getElementById('mergePartsTableName');
    const gridEl = document.getElementById('mergePartsGrid');
    const confirmBtn = document.getElementById('mergePartsConfirmBtn');

    if (nameEl) nameEl.textContent = tableName ? ('‚Äî ' + tableName) : '';
    mergePartsSelected = new Set();

    function updateConfirmState() {
      const count = mergePartsSelected.size;
      if (confirmBtn) confirmBtn.disabled = count < 2;
    }

    if (gridEl) {
      gridEl.textContent = '';
      const n = Math.max(1, parseInt(String(partsCount || 1), 10) || 1);
      for (let i = 1; i <= n; i++) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'choice-btn';
        btn.dataset.partNum = String(i);
        btn.appendChild(document.createTextNode('Section ' + i));
        gridEl.appendChild(btn);
      }
    }

    updateConfirmState();
    mergePartsResolver = resolve;
    popup.style.display = 'flex';

    if (!popup.dataset.bound) {
      const dialog = popup.querySelector('.modal-dialog');

      (dialog || popup).addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-part-num]');
        if (!btn) return;
        const part = parseInt(btn.dataset.partNum || '', 10);
        if (!Number.isFinite(part)) return;

        if (mergePartsSelected.has(part)) {
          mergePartsSelected.delete(part);
          btn.classList.remove('primary');
        } else {
          mergePartsSelected.add(part);
          btn.classList.add('primary');
        }
        updateConfirmState();
      });

      const confirm = document.getElementById('mergePartsConfirmBtn');
      if (confirm) {
        confirm.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (mergePartsSelected.size < 2) return;

          const picked = Array.from(mergePartsSelected);
          picked.sort((a, b) => a - b);

          popup.style.display = 'none';
          const r = mergePartsResolver;
          mergePartsResolver = null;
          mergePartsSelected = new Set();
          if (typeof r === 'function') r(picked);
        });
      }

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          const p = document.getElementById('mergePartsPopup');
          if (p && p.style.display === 'flex') closeMergePartsPopup();
        }
      });

      popup.dataset.bound = '1';
    }

    // Focus first part button for faster use.
    const first = popup.querySelector('button[data-part-num]');
    (first || confirmBtn)?.focus?.();
  });
}

function showActionPopup({ title, message, choices, cancelText = 'Cancel' } = {}) {
  // choices: [{ value:any, label:string, hint?:string, variant?:'primary'|'danger'|'default' }]
  return new Promise((resolve) => {
    const popup = document.getElementById('actionPopup');
    if (!popup) {
      // Minimal fallback.
      alert(String(message || title || ''));
      return resolve(null);
    }

    // Cancel any existing popup.
    if (typeof actionPopupResolver === 'function') {
      const prev = actionPopupResolver;
      actionPopupResolver = null;
      actionPopupChoiceValues = [];
      try { prev(null); } catch (e) {}
    }

    const titleEl = document.getElementById('actionTitle');
    const msgEl = document.getElementById('actionMessage');
    const choicesEl = document.getElementById('actionChoices');
    const cancelBtn = document.getElementById('actionCancelBtn');

    if (titleEl) titleEl.textContent = title || 'Action';
    if (msgEl) msgEl.textContent = message || '';
    if (cancelBtn) {
      const actionsRow = cancelBtn.closest('.form-actions');
      if (cancelText === null) {
        if (actionsRow) actionsRow.style.display = 'none';
      } else {
        if (actionsRow) actionsRow.style.display = 'flex';
        cancelBtn.textContent = cancelText || 'Cancel';
      }
    }

    const normalized = Array.isArray(choices) ? choices : [];
    actionPopupChoiceValues = normalized.map(c => c?.value);

    if (choicesEl) {
      choicesEl.textContent = '';
      for (let i = 0; i < normalized.length; i++) {
        const c = normalized[i] || {};
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'choice-btn' + (c.variant === 'primary' ? ' primary' : (c.variant === 'danger' ? ' danger' : ''));
        btn.dataset.choiceIndex = String(i);

        const main = document.createElement('div');
        main.textContent = String(c.label || 'Select');
        btn.appendChild(main);

        if (c.hint) {
          const small = document.createElement('small');
          small.textContent = String(c.hint);
          btn.appendChild(small);
        }

        choicesEl.appendChild(btn);
      }
    }

    actionPopupResolver = resolve;
    popup.style.display = 'flex';

    if (!popup.dataset.bound) {
      const dialog = popup.querySelector('.modal-dialog');
      (dialog || popup).addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-choice-index]');
        if (!btn) return;
        const idx = parseInt(btn.dataset.choiceIndex || '', 10);
        if (!Number.isFinite(idx) || idx < 0 || idx >= actionPopupChoiceValues.length) return;

        popup.style.display = 'none';
        const r = actionPopupResolver;
        const value = actionPopupChoiceValues[idx];
        actionPopupResolver = null;
        actionPopupChoiceValues = [];
        if (typeof r === 'function') r(value);
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          const p = document.getElementById('actionPopup');
          if (p && p.style.display === 'flex') closeActionPopup();
        }
      });

      popup.dataset.bound = '1';
    }

    // Focus first primary, else first choice.
    const primary = popup.querySelector('.choice-btn.primary');
    const any = popup.querySelector('.choice-btn');
    (primary || any || cancelBtn)?.focus?.();
  });
}

async function showConfirmPopup({ title, message, confirmText = 'Yes', danger = false } = {}) {
  const res = await showActionPopup({
    title,
    message,
    cancelText: null,
    choices: [
      { value: true, label: confirmText, hint: '', variant: danger ? 'danger' : 'primary' },
      { value: false, label: 'No', hint: '', variant: 'default' }
    ]
  });

  return res === true;
}

function promptSelectTablePart(tableName, actionLabel) {
  const parts = getSplitCount(tableName);
  if (parts <= 1) return 1;

  const def = (currentTable === tableName) ? String(currentTablePart) : '1';
  const raw = prompt(
    (actionLabel || 'Select section') + ' for table "' + tableName + '":\n' +
    'Enter 1-' + parts + ':',
    def
  );
  if (raw === null) return null;
  const p = parseInt(String(raw).trim(), 10);
  if (!Number.isFinite(p) || p < 1 || p > parts) {
    alert('Invalid section. Please enter 1-' + parts + '.');
    return null;
  }
  return p;
}

/* Table positions: { "17A": {x: 40, y: 20}, ... } */
let tablePositions = {};

/* Edit layout mode (drag enabled only when true) */
let editLayoutMode = false;

/* Select tables mode (multi-selection enabled when true) */
let selectTablesMode = false;

/* Right-click context menu target */
let contextMenuTable = null;

/* Copied table data for paste */
let copiedTableData = null;

/* Flag to prevent click after drag */
let wasDragged = false;

/* Table sizes: { "17A": {width: 80, height: 80}, ... } */
let tableSizes = {};

/* Selected tables for batch operations: Set of table names */
let selectedTables = new Set();

/* Snap grid for positioning */
const SNAP_GRID = 75; // smaller step = less forced spacing

// Minimum gap between tables (in CSS pixels)
const TABLE_GAP = 6;

function snapToGrid(val) {
  return Math.round(val / SNAP_GRID) * SNAP_GRID;
}

function clamp(val, min, max) {
  return Math.max(min, Math.min(max, val));
}

function getRect(left, top, width, height) {
  return {
    left,
    top,
    right: left + width,
    bottom: top + height,
    width,
    height
  };
}

function rectsOverlap(a, b) {
  return a.left < b.right && a.right > b.left && a.top < b.bottom && a.bottom > b.top;
}

function resolveNonOverlapPosition({
  desiredLeft,
  desiredTop,
  width,
  height,
  otherEls,
  bounds,
  preferDx,
  preferDy
}) {
  let left = desiredLeft;
  let top = desiredTop;

  const iterations = 20;
  for (let i = 0; i < iterations; i++) {
    let moved = false;
    const moving = getRect(left, top, width, height);

    for (const other of otherEls) {
      const otherRect = getRect(
        other.offsetLeft - TABLE_GAP,
        other.offsetTop - TABLE_GAP,
        other.offsetWidth + TABLE_GAP * 2,
        other.offsetHeight + TABLE_GAP * 2
      );

      if (!rectsOverlap(moving, otherRect)) continue;

      const dx = preferDx >= 0
        ? (otherRect.right - moving.left)
        : (otherRect.left - moving.right);
      const dy = preferDy >= 0
        ? (otherRect.bottom - moving.top)
        : (otherRect.top - moving.bottom);

      // Move along the axis that requires the least displacement.
      if (Math.abs(dx) <= Math.abs(dy)) {
        left += dx;
      } else {
        top += dy;
      }

      left = clamp(left, bounds.minLeft, bounds.maxLeft);
      top = clamp(top, bounds.minTop, bounds.maxTop);
      moved = true;
      break;
    }

    if (!moved) break;
  }

  return { left, top };
}

function clampResizeToAvoidOverlap({
  left,
  top,
  width,
  height,
  otherEls,
  minSize
}) {
  let newWidth = width;
  let newHeight = height;

  // Only resizing down/right (corner drag), so only guard right/bottom edges.
  for (let pass = 0; pass < 2; pass++) {
    const right = left + newWidth;
    const bottom = top + newHeight;

    let maxWidth = Infinity;
    let maxHeight = Infinity;

    for (const other of otherEls) {
      const oLeft = other.offsetLeft;
      const oTop = other.offsetTop;
      const oRight = oLeft + other.offsetWidth;
      const oBottom = oTop + other.offsetHeight;

      // Limit width if an element is to the right and vertically overlaps.
      const verticalOverlaps = (top < oBottom + TABLE_GAP) && (bottom + TABLE_GAP > oTop);
      if (verticalOverlaps && oLeft >= left) {
        maxWidth = Math.min(maxWidth, (oLeft - TABLE_GAP) - left);
      }

      // Limit height if an element is below and horizontally overlaps.
      const horizontalOverlaps = (left < oRight + TABLE_GAP) && (right + TABLE_GAP > oLeft);
      if (horizontalOverlaps && oTop >= top) {
        maxHeight = Math.min(maxHeight, (oTop - TABLE_GAP) - top);
      }
    }

    if (Number.isFinite(maxWidth)) newWidth = Math.min(newWidth, maxWidth);
    if (Number.isFinite(maxHeight)) newHeight = Math.min(newHeight, maxHeight);

    if (newWidth < minSize) newWidth = minSize;
    if (newHeight < minSize) newHeight = minSize;
  }

  return { width: newWidth, height: newHeight };
}

/* Load table positions from localStorage */
(function loadTablePositionsFromStorage() {
  const saved = localStorage.getItem("tablePositions");
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      if (parsed && typeof parsed === "object") tablePositions = parsed;
    } catch (e) {
      tablePositions = {};
    }
  }
})();

/* Load table sizes from localStorage */
(function loadTableSizesFromStorage() {
  const saved = localStorage.getItem("tableSizes");
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      if (parsed && typeof parsed === "object") tableSizes = parsed;
    } catch (e) {
      tableSizes = {};
    }
  }
})();

/* Load table split counts from localStorage */
(function loadTableSplitsFromStorage() {
  const saved = localStorage.getItem("tableSplits");
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      if (parsed && typeof parsed === "object") tableSplits = parsed;
    } catch (e) {
      tableSplits = {};
    }
  }
})();

/* Load table split directions from localStorage */
(function loadTableSplitDirectionsFromStorage() {
  const saved = localStorage.getItem("tableSplitDirections");
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      if (parsed && typeof parsed === "object") tableSplitDirections = parsed;
    } catch (e) {
      tableSplitDirections = {};
    }
  }
})();

/* Load manual occupied overrides from localStorage */
(function loadTableOccupiedOverridesFromStorage() {
  const saved = localStorage.getItem("tableOccupiedOverrides");
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      if (parsed && typeof parsed === "object") tableOccupiedOverrides = parsed;
    } catch (e) {
      tableOccupiedOverrides = {};
    }
  }
})();

/* Load needs-cleaning flags from localStorage */
(function loadTableNeedsCleaningFromStorage() {
  const saved = localStorage.getItem("tableNeedsCleaning");
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      if (parsed && typeof parsed === "object") tableNeedsCleaning = parsed;
    } catch (e) {
      tableNeedsCleaning = {};
    }
  }
})();

function saveTablePositions() {
  try {
    localStorage.setItem("tablePositions", JSON.stringify(tablePositions));
  } catch (e) {
    console.error("Failed to save tablePositions:", e);
  }

  try {
    window.schedulePosStateSync && window.schedulePosStateSync({ tablePositions });
  } catch {}
}

function saveTableSizes() {
  try {
    localStorage.setItem("tableSizes", JSON.stringify(tableSizes));
  } catch (e) {
    console.error("Failed to save tableSizes:", e);
  }

  try {
    window.schedulePosStateSync && window.schedulePosStateSync({ tableSizes });
  } catch {}
}

function saveTableSplits() {
  try {
    localStorage.setItem("tableSplits", JSON.stringify(tableSplits));
  } catch (e) {
    console.error("Failed to save tableSplits:", e);
  }

  try {
    window.schedulePosStateSync && window.schedulePosStateSync({ tableSplits });
  } catch {}
}

function saveTableSplitDirections() {
  try {
    localStorage.setItem("tableSplitDirections", JSON.stringify(tableSplitDirections));
  } catch (e) {
    console.error("Failed to save tableSplitDirections:", e);
  }

  try {
    window.schedulePosStateSync && window.schedulePosStateSync({ tableSplitDirections });
  } catch {}
}

function saveTableOccupiedOverrides() {
  try {
    localStorage.setItem("tableOccupiedOverrides", JSON.stringify(tableOccupiedOverrides));
  } catch (e) {
    console.error("Failed to save tableOccupiedOverrides:", e);
  }

  try {
    window.schedulePosStateSync && window.schedulePosStateSync({ tableOccupiedOverrides });
  } catch {}
}

function saveTableNeedsCleaning() {
  try {
    localStorage.setItem("tableNeedsCleaning", JSON.stringify(tableNeedsCleaning));
  } catch (e) {
    console.error("Failed to save tableNeedsCleaning:", e);
  }

  try {
    window.schedulePosStateSync && window.schedulePosStateSync({ tableNeedsCleaning });
  } catch {}
}

function saveOrders() {
  try {
    localStorage.setItem("orders", JSON.stringify(orders));
  } catch (e) {
    console.error("Failed to save orders:", e);
  }

  try {
    window.schedulePosStateSync && window.schedulePosStateSync({ orders });
  } catch {}
}

function updateSplitOverlayInteractivity() {
  document.querySelectorAll('.split-overlay').forEach(el => {
    el.style.pointerEvents = editLayoutMode ? 'none' : 'auto';
  });
}

/* --------------------------------------------------
   TABLE LIST (Editable)
-------------------------------------------------- */
let tableList = [
  "17A","17B","9","8A","7A","6A","5A","4A","3A","2A","1A",
  "18A","18B","10","8B","7B","6B","5B","4B","3B","2B","1B",
  "19A","19B","19C",
  "20",
  "21A","21B","12","8C","7C",
  "22A","22B","13",
  "23A","23B","14A","14B",
  "15A","15B"
];

/* Load table order from localStorage if present */
(function loadTableListFromStorage() {
  const saved = localStorage.getItem("tableList");
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      if (Array.isArray(parsed) && parsed.length > 0) {
        tableList = parsed;
      }
    } catch (e) {
      // keep default
    }
  }
})();

function saveTableList() {
  try {
    localStorage.setItem("tableList", JSON.stringify(tableList));
  } catch (e) {
    console.error("Failed to save tableList:", e);
  }

  try {
    window.schedulePosStateSync && window.schedulePosStateSync({ tableList });
  } catch {}
}

/* --------------------------------------------------
   BUILD TABLE CANVAS
-------------------------------------------------- */
function loadTableMap() {
  const grid = document.getElementById("tableGrid");
  if (grid.replaceChildren) grid.replaceChildren();
  else grid.innerHTML = "";

  // Bind buttons once
  const addBtn = document.getElementById("addTableBtn");
  if (addBtn && !addBtn.dataset.bound) {
    addBtn.addEventListener("click", addTable);
    addBtn.dataset.bound = "1";
  }

  const editBtn = document.getElementById("editLayoutBtn");
  if (editBtn && !editBtn.dataset.bound) {
    editBtn.addEventListener("click", toggleEditLayout);
    editBtn.dataset.bound = "1";
  }

  const selectBtn = document.getElementById("selectTablesBtn");
  if (selectBtn && !selectBtn.dataset.bound) {
    selectBtn.addEventListener("click", toggleSelectTables);
    selectBtn.dataset.bound = "1";
  }

  // Bind batch action buttons
  const paySelectedBtn = document.getElementById("paySelectedBtn");
  if (paySelectedBtn && !paySelectedBtn.dataset.bound) {
    paySelectedBtn.addEventListener("click", paySelectedTables);
    paySelectedBtn.dataset.bound = "1";
  }

  const clearSelectedBtn = document.getElementById("clearSelectedBtn");
  if (clearSelectedBtn && !clearSelectedBtn.dataset.bound) {
    clearSelectedBtn.addEventListener("click", clearSelectedTables);
    clearSelectedBtn.dataset.bound = "1";
  }

  const deselectAllBtn = document.getElementById("deselectAllBtn");
  if (deselectAllBtn && !deselectAllBtn.dataset.bound) {
    deselectAllBtn.addEventListener("click", deselectAllTables);
    deselectAllBtn.dataset.bound = "1";
  }

  const selectAllBtn = document.getElementById("selectAllBtn");
  if (selectAllBtn && !selectAllBtn.dataset.bound) {
    selectAllBtn.addEventListener("click", selectAllTables);
    selectAllBtn.dataset.bound = "1";
  }

  const equalSizeBtn = document.getElementById("equalSizeBtn");
  if (equalSizeBtn && !equalSizeBtn.dataset.bound) {
    equalSizeBtn.addEventListener("click", makeSelectedTablesEqualSize);
    equalSizeBtn.dataset.bound = "1";
  }

  const fragment = document.createDocumentFragment();

  tableList.forEach((t, index) => {
    const div = document.createElement("div");
    div.className = "floor-table";
    div.innerHTML = `
      <button class="arrived-btn" type="button" title="Arrived">‚úÖ</button>
      <div class="table-header">
        <div class="table-label">${t}</div>
        <div class="table-eta"></div>
        <div class="table-menu"></div>
        <div class="table-pax"></div>
        <div class="table-status">Available</div>
      </div>
      <div class="table-content">
        <div class="bill-amount"></div>
      </div>
      <div class="resize-handle"></div>
      <div class="split-overlay" aria-hidden="true"></div>
    `;
    div.dataset.table = t;

    // Cache frequently accessed sub-elements for faster updates
    div._ui = {
      statusEl: div.querySelector('.table-status'),
      etaEl: div.querySelector('.table-eta'),
      menuEl: div.querySelector('.table-menu'),
      paxEl: div.querySelector('.table-pax'),
      billEl: div.querySelector('.table-content .bill-amount'),
      arrivedBtnEl: div.querySelector('.arrived-btn'),
      resizeHandleEl: div.querySelector('.resize-handle'),
      splitOverlayEl: div.querySelector('.split-overlay')
    };


    const arrivedBtn = div._ui?.arrivedBtnEl || div.querySelector('.arrived-btn');
    if (arrivedBtn) {
      arrivedBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (!reservations[t]) return;
        setTableOccupiedOverride(t, true);
        updateTableColors();
      });
    }

    // Position: use saved position or simple default grid-style layout
    let pos = tablePositions[t];
    let x, y;
    if (pos && typeof pos.x === "number" && typeof pos.y === "number") {
      x = pos.x;
      y = pos.y;
    } else {
      const colWidth = 80;
      const rowHeight = 60;
      const col = index % 6;
      const row = Math.floor(index / 6);
      x = 10 + col * colWidth;
      y = 10 + row * rowHeight;
    }
    div.style.left = x + "px";
    div.style.top  = y + "px";

    // Size: use saved size or default
    const size = tableSizes[t] || { width: 80, height: 80 };
    div.style.width = size.width + "px";
    div.style.height = size.height + "px";

    // Scale content to fit (slightly smaller text for dense layouts)
    const scale = Math.min(size.width / 60, size.height / 60);
    div.style.fontSize = (10 * scale) + 'px';
    div.style.padding = (5 * scale) + 'px';
    div.style.setProperty('--btn-pos', (2 * scale) + 'px');
    div.style.setProperty('--scale', scale);

    const resizeHandleEl = div._ui?.resizeHandleEl;
    if (resizeHandleEl) {
      // Hide resize handle if too small
      resizeHandleEl.style.display = scale > 0.5 ? 'block' : 'none';
      // Resize handle
      resizeHandleEl.addEventListener('mousedown', (e) => startResizeTable(e, t, div));
    }
    // Compact mode to prevent icon cut-off on narrow tables
    div.classList.toggle('compact', scale < 0.75);

    // Split overlay (divide within this table box)
    const splitCount = getSplitCount(t);
    const splitDir = getSplitDirection(t);
    const overlay = div._ui?.splitOverlayEl;
    if (overlay) {
      if (overlay.replaceChildren) overlay.replaceChildren();
      else overlay.innerHTML = '';

      if (splitCount > 1) {
        div.classList.add('split');
        overlay.style.pointerEvents = editLayoutMode ? 'none' : 'auto';

        if (splitDir === 'h') {
          // Horizontal division = stacked rows
          overlay.style.gridTemplateColumns = '1fr';
          overlay.style.gridTemplateRows = `repeat(${splitCount}, 1fr)`;
        } else {
          // Vertical division = side-by-side columns
          overlay.style.gridTemplateColumns = `repeat(${splitCount}, 1fr)`;
          overlay.style.gridTemplateRows = '1fr';
        }

        for (let p = 1; p <= splitCount; p++) {
          const cell = document.createElement('button');
          cell.type = 'button';
          cell.className = 'split-cell';
          cell.dataset.part = String(p);
          cell.innerHTML = `
            <div class="split-cell-num">${p}</div>
            <span class="bill-split-pill split-cell-total">‡∏ø 0</span>
          `;
          if (currentTable === t && currentTablePart === p) cell.classList.add('active');

          cell.addEventListener('click', async (e) => {
            e.stopPropagation();
            if (editLayoutMode) {
              div.classList.toggle('selected');
              return;
            }

            if (selectTablesMode) {
              // Toggle selection for this table
              if (selectedTables.has(t)) {
                selectedTables.delete(t);
              } else {
                selectedTables.add(t);
              }
              updateTableSelections();
              return;
            }

            setActiveTable(t, p);
            const isOccupied = tableHasAnyItems(t) || isTableOccupiedOverride(t);
            const needsCleaning = isTableNeedsCleaning(t);
            const hasReservation = !!reservations[t];
            if (isOccupied) {
              if (!tableHasAnyItems(t) && needsCleaning) {
                const ok = await showConfirmPopup({
                  title: 'Needs cleaning',
                  message: `Mark table "${t}" as cleaned and available?`,
                  confirmText: '‚úì Done Cleaning',
                  danger: false
                });
                if (ok) {
                  // Clear everything for this table
                  markTableCleanedAndAvailable(t);
                }
                return;
              }
              showMenuPopup(t);
            } else if (hasReservation) {
              showReservationPopup(t);
            } else {
              const result = await promptWalkInOrReservation(t);
              if (!result) return;
              if (result.choice === 'walkin') {
                // Set pax for default quantity
                setTablePax(t, result.pax);
                showMenuPopup(t);
              } else if (result.choice === 'reservation') {
                // Pass pax to reservation wizard
                showReservationPopup(t, result.pax);
              }
            }
          });

          overlay.appendChild(cell);
        }
      } else {
        div.classList.remove('split');
        overlay.style.pointerEvents = 'none';
      }
    }

    // Left-click = toggle selection in edit mode, else show menu/reservation
    div.addEventListener("click", async () => {
      if (wasDragged) {
        wasDragged = false;
        return;
      }
      if (editLayoutMode) {
        div.classList.toggle("selected");
      } else if (selectTablesMode) {
        // Toggle selection for this table
        if (selectedTables.has(t)) {
          selectedTables.delete(t);
        } else {
          selectedTables.add(t);
        }
        updateTableSelections();
      } else {
        // If this table is split, clicks should go to a part via the overlay.
        // Fallback: treat as part 1.
        setActiveTable(t, 1);
        const isOccupied = tableHasAnyItems(t) || isTableOccupiedOverride(t);
        const needsCleaning = isTableNeedsCleaning(t);
        const hasReservation = !!reservations[t];
        if (isOccupied) {
          if (!tableHasAnyItems(t) && needsCleaning) {
            const ok = await showConfirmPopup({
              title: 'Needs cleaning',
              message: `Mark table "${t}" as cleaned and available?`,
              confirmText: '‚úì Done Cleaning',
              danger: false
            });
            if (ok) {
              // Clear everything for this table
              markTableCleanedAndAvailable(t);
            }
            return;
          }

          showMenuPopup(t);
        } else if (hasReservation) {
          showReservationPopup(t);
        } else {
          const result = await promptWalkInOrReservation(t);
          if (!result) return;
          if (result.choice === 'walkin') {
            // Set pax for default quantity
            setTablePax(t, result.pax);
            showMenuPopup(t);
          } else if (result.choice === 'reservation') {
            // Pass pax to reservation wizard
            showReservationPopup(t, result.pax);
          }
        }
      }
    });

    // Double-click = rename table
    div.addEventListener("dblclick", () => renameTable(t));

    // Right-click / long-press = show custom context menu (mouse only in edit mode)
    div.addEventListener("contextmenu", (e) => {
      if (editLayoutMode && window.__lastTablePointerType && window.__lastTablePointerType !== 'mouse') {
        e.preventDefault();
        return;
      }
      showTableContextMenu(e, t);
    });

    // Drag = move freely, but only in edit mode
    if (window.PointerEvent) {
      div.addEventListener("pointerdown", (e) => startDragTable(e, t, div));
    } else {
      div.addEventListener("mousedown", (e) => startDragTable(e, t, div));
    }

    fragment.appendChild(div);
  });

  grid.appendChild(fragment);

  // Re-apply selected state if any
  if (currentTable) {
    document.querySelectorAll(".floor-table").forEach(el => {
      if (el.dataset.table === currentTable) {
        el.classList.add("selected");
      }
    });
  }

  updateTableColors();
  updateEditLayoutButton();
}

/* --------------------------------------------------
   EDIT LAYOUT TOGGLE
-------------------------------------------------- */
function toggleEditLayout() {
  editLayoutMode = !editLayoutMode;
  updateEditLayoutButton();
  updateSplitOverlayInteractivity();
}

function updateEditLayoutButton() {
  const btn = document.getElementById("editLayoutBtn");
  if (!btn) return;
  if (editLayoutMode) {
    btn.classList.add("active");
    btn.title = "Edit layout (ON)";
  } else {
    btn.classList.remove("active");
    btn.title = "Edit layout (OFF)";
  }

  const grid = document.getElementById('tableGrid');
  if (grid) grid.classList.toggle('edit-mode', !!editLayoutMode);
}

function toggleSelectTables() {
  selectTablesMode = !selectTablesMode;
  updateSelectTablesButton();
  // Clear selections when exiting select mode, or update display when entering
  if (!selectTablesMode) {
    selectedTables.clear();
  }
  updateTableSelections();
}

function updateSelectTablesButton() {
  const btn = document.getElementById("selectTablesBtn");
  if (!btn) return;
  if (selectTablesMode) {
    btn.classList.add("active");
    btn.title = "Select tables (ON)";
  } else {
    btn.classList.remove("active");
    btn.title = "Select tables (OFF)";
  }

  const grid = document.getElementById('tableGrid');
  if (grid) grid.classList.toggle('select-mode', !!selectTablesMode);
}

function updateTableSelections() {
  document.querySelectorAll('.floor-table').forEach(tableEl => {
    const tableName = tableEl.dataset.table;
    tableEl.classList.toggle('multi-selected', selectedTables.has(tableName));
  });

  // Show/hide batch actions and buttons based on state
  const batchActions = document.getElementById('batchActions');
  const selectAllBtn = document.getElementById('selectAllBtn');
  const equalSizeBtn = document.getElementById('equalSizeBtn');
  const paySelectedBtn = document.getElementById('paySelectedBtn');
  const clearSelectedBtn = document.getElementById('clearSelectedBtn');
  const deselectAllBtn = document.getElementById('deselectAllBtn');

  if (batchActions && selectAllBtn && equalSizeBtn && paySelectedBtn && clearSelectedBtn && deselectAllBtn) {
    if (selectTablesMode) {
      batchActions.style.display = 'flex';
      if (selectedTables.size > 0) {
        selectAllBtn.style.display = 'none';
        equalSizeBtn.style.display = 'inline-block';
        paySelectedBtn.style.display = 'inline-block';
        clearSelectedBtn.style.display = 'inline-block';
        deselectAllBtn.style.display = 'inline-block';
      } else {
        selectAllBtn.style.display = 'inline-block';
        equalSizeBtn.style.display = 'none';
        paySelectedBtn.style.display = 'none';
        clearSelectedBtn.style.display = 'none';
        deselectAllBtn.style.display = 'none';
      }
    } else {
      batchActions.style.display = 'none';
    }
  }
  
  // Broadcast selection changes to other clients
  if (socket && socket.connected) {
    socket.emit('tableSelection', { selectedTables: Array.from(selectedTables) });
  }
}

function paySelectedTables() {
  if (selectedTables.size === 0) return;

  const tables = Array.from(selectedTables).filter(table => tableHasAnyItems(table));
  if (tables.length === 0) {
    alert('No selected tables have active bills.');
    return;
  }

  if (tables.length === 1) {
    // Single table - pay directly
    payTable(tables[0]);
    selectedTables.clear();
    updateTableSelections();
    return;
  }

  const message = `Pay bills for selected tables: ${tables.join(', ')}?\n\nYou will need to pay each table individually.`;
  showConfirmPopup({
    title: 'Pay Selected Tables',
    message: message,
    confirmText: 'Start with First Table',
    danger: false
  }).then(ok => {
    if (ok) {
      // Start with first table
      payTable(tables[0]);
      // Keep selections for user to continue manually
    }
  });
}

function clearSelectedTables() {
  if (selectedTables.size === 0) return;

  const tables = Array.from(selectedTables);
  const message = `Clear all data for selected tables: ${tables.join(', ')}?\n\nThis will remove bills, reservations, and pax counts.`;
  showConfirmPopup({
    title: 'Clear Selected Tables',
    message: message,
    confirmText: 'Clear All',
    danger: true
  }).then(ok => {
    if (ok) {
      tables.forEach(table => {
        clearTableAndMakeAvailable(table);
      });
      selectedTables.clear();
      updateTableSelections();
    }
  });
}

function deselectAllTables() {
  selectedTables.clear();
  updateTableSelections();
}

function selectAllTables() {
  tableList.forEach(table => {
    selectedTables.add(table);
  });
  updateTableSelections();
}

function makeSelectedTablesEqualSize() {
  if (selectedTables.size === 0) return;

  // Calculate average size from selected tables
  let totalWidth = 0;
  let totalHeight = 0;
  let count = 0;

  selectedTables.forEach(table => {
    const size = tableSizes[table] || { width: 80, height: 80 };
    totalWidth += size.width;
    totalHeight += size.height;
    count++;
  });

  const avgWidth = Math.round(totalWidth / count);
  const avgHeight = Math.round(totalHeight / count);

  // Apply average size to all selected tables
  selectedTables.forEach(table => {
    tableSizes[table] = { width: avgWidth, height: avgHeight };
  });

  // Save and refresh
  saveTableSizes();
  loadTableMap();

  // Broadcast size changes to other clients
  if (socket && socket.connected) {
    socket.emit('tableSizesUpdate', { tableSizes });
  }
}

/* --------------------------------------------------
   RESET LAYOUT POSITIONS
-------------------------------------------------- */
async function resetLayoutPositions() {
  const ok = await showConfirmPopup({
    title: 'Reset Layout',
    message:
      "Reset table layout positions?\n\n" +
      "This will only move tables back into a clean grid.\n" +
      "Bills and table names will NOT be cleared.",
    confirmText: 'Reset',
    danger: true
  });
  if (!ok) return;

  tablePositions = {};
  try { localStorage.removeItem("tablePositions"); } catch (e) {}
  loadTableMap();
}

/* --------------------------------------------------
   RIGHT-CLICK CONTEXT MENU
-------------------------------------------------- */
function initTableContextMenu() {
  const menu = document.getElementById("tableContextMenu");
  if (!menu) return;

  // Click on menu item
  menu.addEventListener("click", (e) => {
    const item = e.target.closest(".menu-item");
    if (!item) return;

    const action = item.dataset.action;
    const tableName = contextMenuTable;
    hideTableContextMenu();

    if (!tableName) return;

    if (action === "copy") {
      copyTable(tableName);
    } else if (action === "paste") {
      pasteTable();
    } else if (action === "makeAvailable") {
      clearTableAndMakeAvailable(tableName);
    } else if (action === "split") {
      splitTable(tableName);
    } else if (action === "revertSplit") {
      revertSplitTable(tableName);
    } else if (action === "convertSplit") {
      convertHyphenSplitTables(tableName);
    } else if (action === "rename") {
      renameTable(tableName);
    } else if (action === "resize") {
      resizeTable(tableName);
    } else if (action === "selectAll") {
      selectAllTables();
    } else if (action === "equalSize") {
      makeAllEqualSize();
    } else if (action === "resizeSelected") {
      resizeSelectedTables();
    } else if (action === "equalSizeSelected") {
      makeSelectedEqualSize();
    } else if (action === "delete") {
      deleteTable(tableName);
    }
  });

  // Click anywhere else hides menu
  document.addEventListener("click", () => {
    hideTableContextMenu();
  });

  // Hide on scroll as well
  document.addEventListener("scroll", () => {
    hideTableContextMenu();
  }, true);
}

/* --------------------------------------------------
   CLEAR TABLE & MAKE AVAILABLE (from context menu)
-------------------------------------------------- */
function clearTableOrders(name) {
  ensureTableMemory(name);
  const parts = getSplitCount(name);
  if (parts === 1) {
    orders[name] = [];
  } else {
    orders[name] = Array.from({ length: parts }, () => []);
  }

  saveOrders();

  if (currentTable === name) {
    items = getOrderList(name, currentTablePart);
    renderBillTable();
    if (typeof updateReceiptPreview === "function") {
      updateReceiptPreview();
    }
  }
}

async function clearTableAndMakeAvailable(name) {
  const hasItems = tableHasAnyItems(name);
  const hadOverride = isTableOccupiedOverride(name);
  const hadCleaning = isTableNeedsCleaning(name);

  if (!hasItems && !hadOverride && !hadCleaning) {
    // Already available.
    return;
  }

  const ok = await showConfirmPopup({
    title: "Change Status",
    message:
      'Change status for table "' + name + '"?\n\n' +
      (hasItems ? "This will CLEAR the bill items for this table.\n\n" : "") +
      "This will also remove Occupied / Needs cleaning status.",
    confirmText: "Change Status",
    danger: hasItems
  });
  if (!ok) return;

  clearTableOrders(name);
  try { setTableNeedsCleaning(name, false); } catch (e) {}
  try { setTableOccupiedOverride(name, false); } catch (e) {}

  updateTableColors();
}

function showTableContextMenu(e, tableName) {
  e.preventDefault();

  const menu = document.getElementById("tableContextMenu");
  if (!menu) return;

  contextMenuTable = tableName;

  menu.style.display = "block";

  // Show/hide selected options
  const selected = document.querySelectorAll('.floor-table.selected');
  const resizeSelectedItem = menu.querySelector('[data-action="resizeSelected"]');
  const equalSizeSelectedItem = menu.querySelector('[data-action="equalSizeSelected"]');
  if (selected.length > 1) {
    resizeSelectedItem.style.display = 'block';
    equalSizeSelectedItem.style.display = 'block';
  } else {
    resizeSelectedItem.style.display = 'none';
    equalSizeSelectedItem.style.display = 'none';
  }

  // Position near cursor, but keep inside viewport
  let x = e.clientX;
  let y = e.clientY;

  const menuWidth  = menu.offsetWidth || 140;
  const menuHeight = menu.offsetHeight || 80;

  if (x + menuWidth > window.innerWidth) {
    x = window.innerWidth - menuWidth - 5;
  }
  if (y + menuHeight > window.innerHeight) {
    y = window.innerHeight - menuHeight - 5;
  }

  menu.style.left = x + "px";
  menu.style.top  = y + "px";
}

function hideTableContextMenu() {
  const menu = document.getElementById("tableContextMenu");
  if (!menu) return;
  menu.style.display = "none";
  contextMenuTable = null;
}

/* --------------------------------------------------
   DRAG TABLE FREELY INSIDE CANVAS (ONLY IF EDIT MODE ON)
-------------------------------------------------- */
function startDragTable(e, tableName, el) {
  // Only primary button (when applicable), and only in edit layout mode
  if (!editLayoutMode) return;
  if (typeof e.button === 'number' && e.button !== 0) return;

  // Don't start dragging when interacting with controls inside the tile.
  if (e.target && e.target.closest && e.target.closest('button, .resize-handle, .split-overlay')) return;

  // Track pointer type so touch long-press doesn't trigger context menu in edit mode.
  if (e.pointerType) window.__lastTablePointerType = e.pointerType;

  const usePointer = !!window.PointerEvent && String(e.type) === 'pointerdown';
  const pointerType = String(e.pointerType || 'mouse');
  const isTouchLike = pointerType === 'touch' || pointerType === 'pen';
  const pointerId = typeof e.pointerId === 'number' ? e.pointerId : null;

  const grid = document.getElementById("tableGrid");
  const downX = e.clientX;
  const downY = e.clientY;

  const LONG_PRESS_MS = 450;
  const CANCEL_MOVE_PX = 12;

  let startX = downX;
  let startY = downY;
  let initialLeft = 0;
  let initialTop = 0;
  let bounds = null;
  let otherEls = [];

  let lastClientX = downX;
  let lastClientY = downY;
  let rafId = 0;
  let dragStarted = false;
  let longPressTimer = 0;

  function initDragGeometry() {
    initialLeft = parseInt(el.style.left || "0", 10);
    initialTop  = parseInt(el.style.top  || "0", 10);

    const maxLeft = grid.clientWidth  - el.offsetWidth;
    const maxTop  = grid.clientHeight - el.offsetHeight;
    bounds = { minLeft: 0, minTop: 0, maxLeft: Math.max(0, maxLeft), maxTop: Math.max(0, maxTop) };
    otherEls = Array.from(grid.querySelectorAll('.floor-table')).filter(x => x !== el);
  }

  function beginDrag() {
    if (dragStarted) return;
    dragStarted = true;
    wasDragged = true;

    // Prevent scrolling/selection once drag begins.
    try { e.preventDefault(); } catch {}

    initDragGeometry();

    if (usePointer && pointerId !== null && el.setPointerCapture) {
      try { el.setPointerCapture(pointerId); } catch {}
    }

    const moveEvt = usePointer ? 'pointermove' : 'mousemove';
    const upEvt = usePointer ? 'pointerup' : 'mouseup';
    const cancelEvt = usePointer ? 'pointercancel' : null;

    document.addEventListener(moveEvt, onMove, { passive: false });
    document.addEventListener(upEvt, onUp, { passive: true });
    if (cancelEvt) document.addEventListener(cancelEvt, onUp, { passive: true });
  }

  function applyMove() {
    rafId = 0;

    const dx = lastClientX - startX;
    const dy = lastClientY - startY;

    let newLeft = initialLeft + dx;
    let newTop  = initialTop  + dy;

    newLeft = clamp(newLeft, bounds.minLeft, bounds.maxLeft);
    newTop  = clamp(newTop, bounds.minTop, bounds.maxTop);

    el.style.left = newLeft + "px";
    el.style.top  = newTop  + "px";
  }

  function onMove(ev) {
    // If we're waiting for a long-press, cancel it if user moves too much.
    if (!dragStarted && isTouchLike) {
      const dx0 = ev.clientX - downX;
      const dy0 = ev.clientY - downY;
      if (Math.hypot(dx0, dy0) > CANCEL_MOVE_PX) {
        if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = 0;
        }
        cleanupPreDragListeners();
      }
      return;
    }

    if (dragStarted && isTouchLike) {
      try { ev.preventDefault(); } catch {}
    }

    lastClientX = ev.clientX;
    lastClientY = ev.clientY;
    if (!rafId) rafId = requestAnimationFrame(applyMove);
  }

  function cleanupPreDragListeners() {
    const moveEvt = usePointer ? 'pointermove' : 'mousemove';
    const upEvt = usePointer ? 'pointerup' : 'mouseup';
    const cancelEvt = usePointer ? 'pointercancel' : null;
    document.removeEventListener(moveEvt, onMove);
    document.removeEventListener(upEvt, onPreUp);
    if (cancelEvt) document.removeEventListener(cancelEvt, onPreUp);
  }

  function cleanupDragListeners() {
    const moveEvt = usePointer ? 'pointermove' : 'mousemove';
    const upEvt = usePointer ? 'pointerup' : 'mouseup';
    const cancelEvt = usePointer ? 'pointercancel' : null;
    document.removeEventListener(moveEvt, onMove);
    document.removeEventListener(upEvt, onUp);
    if (cancelEvt) document.removeEventListener(cancelEvt, onUp);
  }

  function onPreUp() {
    // Finger lifted before long-press => do nothing.
    if (longPressTimer) {
      clearTimeout(longPressTimer);
      longPressTimer = 0;
    }
    cleanupPreDragListeners();
  }

  function onUp() {
    cleanupDragListeners();

  if (rafId) {
    cancelAnimationFrame(rafId);
    rafId = 0;
    applyMove();
  }

  // Save final position, snapped to grid (but never overlapping)
  const leftPos = parseInt(el.style.left || "0", 10);
  const topPos  = parseInt(el.style.top  || "0", 10);

  const snappedX = clamp(snapToGrid(leftPos), bounds.minLeft, bounds.maxLeft);
  const snappedY = clamp(snapToGrid(topPos), bounds.minTop, bounds.maxTop);

  const preferDx = lastClientX - startX;
  const preferDy = lastClientY - startY;

  const resolved = resolveNonOverlapPosition({
    desiredLeft: snappedX,
    desiredTop: snappedY,
    width: el.offsetWidth,
    height: el.offsetHeight,
    otherEls,
    bounds,
    preferDx,
    preferDy
  });

    tablePositions[tableName] = { x: resolved.left, y: resolved.top };
    saveTablePositions();

    // Update the element position
    el.style.left = resolved.left + "px";
    el.style.top  = resolved.top  + "px";

    setTimeout(() => wasDragged = false, 10);
  }

  // Mouse: drag immediately. Touch/pen: require long-press.
  if (!isTouchLike) {
    beginDrag();
  } else {
    const moveEvt = usePointer ? 'pointermove' : 'mousemove';
    const upEvt = usePointer ? 'pointerup' : 'mouseup';
    const cancelEvt = usePointer ? 'pointercancel' : null;

    document.addEventListener(moveEvt, onMove, { passive: false });
    document.addEventListener(upEvt, onPreUp, { passive: true });
    if (cancelEvt) document.addEventListener(cancelEvt, onPreUp, { passive: true });

    longPressTimer = setTimeout(() => {
      // Lock the drag start reference at the moment the long press triggers.
      startX = lastClientX;
      startY = lastClientY;
      beginDrag();
    }, LONG_PRESS_MS);
  }
}

/* --------------------------------------------------
   RESIZE TABLE BY DRAGGING CORNER
-------------------------------------------------- */
function startResizeTable(e, tableName, el) {
  if (!editLayoutMode) return; // Only allow resize in edit mode

  e.preventDefault();
  e.stopPropagation(); // Prevent triggering drag

  const startX = e.clientX;
  const startY = e.clientY;

  const initialWidth = el.offsetWidth;
  const initialHeight = el.offsetHeight;

  const handle = el._ui?.resizeHandleEl || el.querySelector('.resize-handle');
  const grid = document.getElementById('tableGrid');
  const otherEls = grid ? Array.from(grid.querySelectorAll('.floor-table')).filter(x => x !== el) : [];
  let lastClientX = startX;
  let lastClientY = startY;
  let rafId = 0;

  function applyResize() {
    rafId = 0;

    const dx = lastClientX - startX;
    const dy = lastClientY - startY;

    let newWidth = initialWidth + dx;
    let newHeight = initialHeight + dy;

    const minSize = 40;
    if (newWidth < minSize) newWidth = minSize;
    if (newHeight < minSize) newHeight = minSize;

    // Prevent overlap while resizing (anchored at top-left)
    const clamped = clampResizeToAvoidOverlap({
      left: el.offsetLeft,
      top: el.offsetTop,
      width: newWidth,
      height: newHeight,
      otherEls,
      minSize
    });
    newWidth = clamped.width;
    newHeight = clamped.height;

    el.style.width = newWidth + "px";
    el.style.height = newHeight + "px";

    const scale = Math.min(newWidth / 60, newHeight / 60);
    el.style.fontSize = (12 * scale) + 'px';
    el.style.padding = (6 * scale) + 'px';
    el.style.setProperty('--btn-pos', (2 * scale) + 'px');
    el.style.setProperty('--scale', scale);
    if (handle) handle.style.display = scale > 0.5 ? 'block' : 'none';
    el.classList.toggle('compact', scale < 0.75);
  }

  function onMove(ev) {
    lastClientX = ev.clientX;
    lastClientY = ev.clientY;
    if (!rafId) rafId = requestAnimationFrame(applyResize);
  }

  function onUp() {
    document.removeEventListener("mousemove", onMove);
    document.removeEventListener("mouseup", onUp);

    if (rafId) {
      cancelAnimationFrame(rafId);
      rafId = 0;
      applyResize();
    }

    // Save final size
    const width = el.offsetWidth;
    const height = el.offsetHeight;

    tableSizes[tableName] = { width, height };
    saveTableSizes();

    // Update scale
    const scale = Math.min(width / 60, height / 60);
    el.style.fontSize = (12 * scale) + 'px';
    el.style.padding = (6 * scale) + 'px';
    el.style.setProperty('--btn-pos', (2 * scale) + 'px');
    el.style.setProperty('--scale', scale);
    // Hide resize handle if too small
    if (handle) handle.style.display = scale > 0.5 ? 'block' : 'none';
    el.classList.toggle('compact', scale < 0.75);
  }

  document.addEventListener("mousemove", onMove);
  document.addEventListener("mouseup", onUp);
}

/* --------------------------------------------------
   ADD TABLE (via + Table button)
-------------------------------------------------- */
function addTable() {
  let name = prompt("New table name:");

  if (name === null) return;  // cancel

  name = name.trim();
  if (!name) {
    alert("Table name cannot be empty.");
    return;
  }

  if (tableList.includes(name)) {
    alert("A table with this name already exists.");
    return;
  }

  tableList.push(name);
  ensureTableMemory(name);
  saveTableList();

  // Give it default position (top left region)
  tablePositions[name] = { x: 20, y: 20 };
  saveTablePositions();

  setActiveTable(name, 1);

  loadTableMap();
  renderBillTable();
  updateTableColors();
}

/* --------------------------------------------------
 

function closeReceiptPopup() {
  document.getElementById('receiptPopup').style.display = 'none';
}

/* --------------------------------------------------
   ADMIN POPUP (Embed admin pages inside POS)
-------------------------------------------------- */
function showAdminPopup(path = '/reservations.html'){
  const p = document.getElementById('adminPopup');
  if (p) p.style.display = 'flex';
  openAdminPage(path);
}

function closeAdminPopup() {
  const p = document.getElementById('adminPopup');
  if (p) p.style.display = 'none';
}

function openAdminPage(path) {
  const frame = document.getElementById('adminFrame');
  if (!frame) return;
  const safe = String(path || '/');

  const withEmbedParam = (url) => {
    const u = String(url || '/');
    const hashIndex = u.indexOf('#');
    const base = hashIndex >= 0 ? u.slice(0, hashIndex) : u;
    const hash = hashIndex >= 0 ? u.slice(hashIndex) : '';

    const hasQuery = base.includes('?');
    const join = hasQuery ? '&' : '?';
    if (/([?&])embed=1(&|$)/.test(base)) return base + hash;
    return base + join + 'embed=1' + hash;
  };

  frame.onload = () => {
    try {
      const doc = frame.contentDocument;
      if (!doc) return;

      // Only apply if we're in embed mode.
      const qs = new URLSearchParams(String(frame.contentWindow?.location?.search || ''));
      if (qs.get('embed') !== '1') return;

      const id = 'pos-embed-admin-style';
      if (!doc.getElementById(id)) {
        const style = doc.createElement('style');
        style.id = id;
        style.textContent = `
          header { display: none !important; }
          main { padding: 12px !important; max-width: none !important; }
          body { margin: 0 !important; }
        `;
        doc.head.appendChild(style);
      }

      // Keep embed mode when navigating inside the iframe.
      // Some admin pages use normal <a href="/customers.html"> links; without embed=1
      // the next page would show the full header/nav again.
      const anchors = Array.from(doc.querySelectorAll('a[href]'));
      for (const a of anchors) {
        const href = a.getAttribute('href');
        if (!href) continue;
        if (href.startsWith('http:') || href.startsWith('https:') || href.startsWith('mailto:') || href.startsWith('tel:')) continue;
        if (href.startsWith('#')) continue;

        // Only rewrite same-site absolute paths.
        if (href.startsWith('/')) {
          const rewritten = withEmbedParam(href);
          a.setAttribute('href', rewritten);
          // Keep navigation inside the iframe.
          if (a.getAttribute('target') === '_blank') a.removeAttribute('target');
        }
      }
    } catch (e) {
      // Ignore cross-frame errors
    }
  };

  frame.src = withEmbedParam(safe);
}

/* --------------------------------------------------
   PAY TABLE / PAYMENT MODAL
-------------------------------------------------- */
let exchangeRates = { usd: 0.029, krw: 39.5 };

async function loadExchangeRates() {
  try {
    const res = await fetch('/api/exchange-rates');
    if (res.ok) {
      const data = await res.json();
      exchangeRates = data.rates || exchangeRates;
    }
  } catch (e) {
    console.log('Could not load exchange rates, using defaults');
  }
}

function payTable(t) {
  let part = currentTablePart;
  if (currentTable !== t) {
    const chosen = promptSelectTablePart(t, 'Pay section');
    if (chosen === null) return;
    part = chosen;
  }
  setActiveTable(t, part);
  showPaymentModal();
}

function showPaymentModal() {
  if (!currentTable) {
    alert('Please select a table first.');
    return;
  }
  
  // Load latest exchange rates
  loadExchangeRates();
  
  const label = (getSplitCount(currentTable) > 1) 
    ? `${currentTable} (${currentTablePart}/${getSplitCount(currentTable)})` 
    : currentTable;
  
  document.getElementById('paymentTableName').textContent = label;
  document.getElementById('taxInvoiceToggle').checked = false;
  
  updatePaymentModal();
  document.getElementById('paymentModal').style.display = 'flex';
}

function closePaymentModal() {
  document.getElementById('paymentModal').style.display = 'none';
}

/* --------------------------------------------------
   SHOW MENU POPUP
   -------------------------------------------------- */
function showMenuPopup(t) {
  if (currentTable !== t) setActiveTable(t, 1);
  else setActiveTable(t, currentTablePart);
  const label = (getSplitCount(t) > 1) ? `${t} (${currentTablePart}/${getSplitCount(t)})` : t;
  document.getElementById('popupTableName').textContent = label;
  document.getElementById('menuPopup').style.display = 'flex';
  renderBillTable(); // Update bill for the table
  updateMenuBadges(); // Show quantity badges on menu items
}

function closeMenuPopup() {
  document.getElementById('menuPopup').style.display = 'none';
}

// Store the current payment grand total in Baht
let paymentGrandTotalBaht = 0;
let selectedPaymentCurrency = 'baht'; // Track which currency is selected for numpad
let paymentAmounts = { baht: '0', dollar: '0', won: '0' }; // Store as strings for numpad

function selectPaymentCurrency(currency) {
  selectedPaymentCurrency = currency;
  
  // Update border highlights
  document.getElementById('payBahtRow').style.border = currency === 'baht' ? '3px solid #1976d2' : '3px solid transparent';
  document.getElementById('payDollarRow').style.border = currency === 'dollar' ? '3px solid #388e3c' : '3px solid transparent';
  document.getElementById('payWonRow').style.border = currency === 'won' ? '3px solid #d32f2f' : '3px solid transparent';
  
  // Update background to show selection
  document.getElementById('payBahtRow').style.background = currency === 'baht' ? '#e3f2fd' : '#fff';
  document.getElementById('payDollarRow').style.background = currency === 'dollar' ? '#e8f5e9' : '#fff';
  document.getElementById('payWonRow').style.background = currency === 'won' ? '#ffebee' : '#fff';
}

function payNumpadPress(key) {
  let current = paymentAmounts[selectedPaymentCurrency];
  
  if (key === 'clear') {
    current = '0';
  } else if (key === 'backspace') {
    current = current.length > 1 ? current.slice(0, -1) : '0';
  } else if (key === 'exact') {
    // Fill exact remaining amount for this currency
    const remaining = getRemainingInCurrency(selectedPaymentCurrency);
    if (remaining > 0) {
      if (selectedPaymentCurrency === 'dollar') {
        current = remaining.toFixed(2);
      } else {
        current = Math.ceil(remaining).toString();
      }
    }
  } else if (key === '.') {
    // Only allow decimal for dollar
    if (selectedPaymentCurrency === 'dollar' && !current.includes('.')) {
      current += '.';
    }
  } else {
    // Number keys
    if (current === '0' && key !== '00' && key !== '000') {
      current = key;
    } else {
      // Limit decimal places for dollar
      if (selectedPaymentCurrency === 'dollar' && current.includes('.')) {
        const parts = current.split('.');
        if (parts[1].length >= 2) return; // Already 2 decimal places
      }
      current += key;
    }
  }
  
  paymentAmounts[selectedPaymentCurrency] = current;
  updatePaymentDisplays();
  calculatePaymentRemaining();
}

function getRemainingInCurrency(currency) {
  // Get current payments
  const payBaht = parseFloat(paymentAmounts.baht) || 0;
  const payDollar = parseFloat(paymentAmounts.dollar) || 0;
  const payWon = parseFloat(paymentAmounts.won) || 0;
  
  const usdToBaht = exchangeRates.usd > 0 ? (1 / exchangeRates.usd) : 0;
  const wonToBaht = exchangeRates.krw > 0 ? (1 / exchangeRates.krw) : 0;
  
  // Don't count the current currency's payment
  let totalPaidInBaht = 0;
  if (currency !== 'baht') totalPaidInBaht += payBaht;
  if (currency !== 'dollar') totalPaidInBaht += payDollar * usdToBaht;
  if (currency !== 'won') totalPaidInBaht += payWon * wonToBaht;
  
  const remainingBaht = paymentGrandTotalBaht - totalPaidInBaht;
  
  if (currency === 'baht') return remainingBaht;
  if (currency === 'dollar') return remainingBaht * exchangeRates.usd;
  if (currency === 'won') return remainingBaht * exchangeRates.krw;
  return 0;
}

function updatePaymentDisplays() {
  // Update display spans
  document.getElementById('payBahtDisplay').textContent = formatPaymentDisplay(paymentAmounts.baht, 'baht');
  document.getElementById('payDollarDisplay').textContent = formatPaymentDisplay(paymentAmounts.dollar, 'dollar');
  document.getElementById('payWonDisplay').textContent = formatPaymentDisplay(paymentAmounts.won, 'won');
  
  // Update hidden inputs
  document.getElementById('payBahtInput').value = paymentAmounts.baht;
  document.getElementById('payDollarInput').value = paymentAmounts.dollar;
  document.getElementById('payWonInput').value = paymentAmounts.won;
}

function formatPaymentDisplay(value, currency) {
  const num = parseFloat(value) || 0;
  if (currency === 'dollar') {
    // Show raw string while typing to preserve decimal input
    if (value.endsWith('.') || (value.includes('.') && value.endsWith('0') && value.split('.')[1].length < 2)) {
      return value;
    }
    return num.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 2 });
  }
  return Math.floor(num).toLocaleString();
}

function updatePaymentModal() {
  const totals = calculateTotals();
  const isTaxInvoice = document.getElementById('taxInvoiceToggle').checked;
  
  // Calculate amounts - VAT is already included in menu prices
  // Subtotal already includes 7% VAT
  // For Tax Invoice, we add an EXTRA 7% on top
  const subtotal = totals.subtotal;
  const discount = totals.discount;
  const totalAfterDiscount = subtotal - discount;
  const extraVat = isTaxInvoice ? Math.round(totalAfterDiscount * 0.07) : 0;
  const grandTotal = totalAfterDiscount + extraVat;
  
  // Store for payment calculation
  paymentGrandTotalBaht = grandTotal;
  
  // Update bill summary display (new layout)
  document.getElementById('paymentSubtotal').textContent = Math.round(subtotal).toLocaleString() + ' ‡∏ø';
  document.getElementById('paymentDiscount').textContent = discount > 0 ? '-' + Math.round(discount).toLocaleString() + ' ‡∏ø' : '0 ‡∏ø';
  document.getElementById('paymentTotal').textContent = Math.round(grandTotal).toLocaleString() + ' ‡∏ø';
  // Show/hide tax invoice note
  const taxNote = document.getElementById('taxInvoiceNote');
  if (taxNote) {
    taxNote.style.display = isTaxInvoice ? 'block' : 'none';
    if (isTaxInvoice) taxNote.textContent = '+7% VAT: ' + Math.round(extraVat).toLocaleString() + ' ‡∏ø';
  }
  
  // Update exchange rate info display
  const usdToBaht = exchangeRates.usd > 0 ? (1 / exchangeRates.usd).toFixed(2) : '0';
  const wonToBaht = exchangeRates.krw > 0 ? (1000 / exchangeRates.krw).toFixed(2) : '0';
  document.getElementById('rateUsdToBaht').textContent = usdToBaht;
  document.getElementById('rateWonToBaht').textContent = wonToBaht;
  
  // Reset payment amounts
  paymentAmounts = { baht: '0', dollar: '0', won: '0' };
  updatePaymentDisplays();
  
  // Select baht by default
  selectPaymentCurrency('baht');
  
  // Calculate and display remaining
  calculatePaymentRemaining();
}

function calculatePaymentRemaining() {
  // Get payment amounts from inputs
  const payBaht = parseFloat(document.getElementById('payBahtInput').value) || 0;
  const payDollar = parseFloat(document.getElementById('payDollarInput').value) || 0;
  const payWon = parseFloat(document.getElementById('payWonInput').value) || 0;
  
  // Convert all payments to Baht
  // exchangeRates.usd is Baht to USD rate (e.g., 0.029 means 1 THB = 0.029 USD)
  // So 1 USD = 1/0.029 THB
  const usdToBaht = exchangeRates.usd > 0 ? (1 / exchangeRates.usd) : 0;
  const wonToBaht = exchangeRates.krw > 0 ? (1 / exchangeRates.krw) : 0;
  
  const payDollarInBaht = payDollar * usdToBaht;
  const payWonInBaht = payWon * wonToBaht;
  const totalPaidInBaht = payBaht + payDollarInBaht + payWonInBaht;
  
  // Calculate remaining
  const remainingBaht = paymentGrandTotalBaht - totalPaidInBaht;
  
  // Show remaining section or change section
  const remainingSection = document.getElementById('paymentRemainingSection');
  const changeSection = document.getElementById('paymentChangeSection');
  const confirmBtn = document.getElementById('confirmPaymentBtn');
  
  if (remainingBaht > 0.01) {
    // Still owes money
    remainingSection.style.display = 'block';
    changeSection.style.display = 'none';
    
    // Convert remaining to all currencies
    const remainingUsd = remainingBaht * exchangeRates.usd;
    const remainingWon = remainingBaht * exchangeRates.krw;
    
    document.getElementById('remainingBaht').textContent = Math.ceil(remainingBaht).toLocaleString() + ' ‡∏ø';
    document.getElementById('remainingDollar').textContent = '$' + remainingUsd.toFixed(2);
    document.getElementById('remainingWon').textContent = '‚Ç©' + Math.ceil(remainingWon).toLocaleString();
    
    // Update section color based on how close to full payment
    const percentPaid = (totalPaidInBaht / paymentGrandTotalBaht) * 100;
    if (percentPaid > 0) {
      remainingSection.style.background = '#fff8e1'; // Yellow when partially paid
    } else {
      remainingSection.style.background = '#ffebee'; // Red when nothing paid
    }
    
    // Disable confirm button until fully paid
    confirmBtn.disabled = true;
    confirmBtn.style.opacity = '0.5';
  } else {
    // Fully paid or overpaid
    remainingSection.style.display = 'none';
    
    // Enable confirm button
    confirmBtn.disabled = false;
    confirmBtn.style.opacity = '1';
    
    if (remainingBaht < -0.01) {
      // Overpaid - show change
      changeSection.style.display = 'block';
      const change = Math.abs(remainingBaht);
      document.getElementById('changeAmount').textContent = Math.round(change).toLocaleString() + ' ‡∏ø';
    } else {
      // Exact payment
      changeSection.style.display = 'none';
    }
  }
}

function openDiscountFromPayment() {
  closePaymentModal();
  showDiscountPopup();
}

async function confirmPayment() {
  if (!currentTable) return;

  // Check if payment is sufficient
  const payBaht = parseFloat(document.getElementById('payBahtInput').value) || 0;
  const payDollar = parseFloat(document.getElementById('payDollarInput').value) || 0;
  const payWon = parseFloat(document.getElementById('payWonInput').value) || 0;

  const usdToBaht = exchangeRates.usd > 0 ? (1 / exchangeRates.usd) : 0;
  const wonToBaht = exchangeRates.krw > 0 ? (1 / exchangeRates.krw) : 0;

  const totalPaidInBaht = payBaht + (payDollar * usdToBaht) + (payWon * wonToBaht);

  if (totalPaidInBaht < paymentGrandTotalBaht - 0.01) {
    alert('Payment is not sufficient. Please enter the full amount.');
    return;
  }

  const isTaxInvoice = document.getElementById('taxInvoiceToggle').checked;

  // Print receipt(s) before clearing the table
  // Store items temporarily for printing
  const itemsForPrint = [...items];
  const tableForPrint = currentTable;
  const partForPrint = currentTablePart;

  // Set print mode based on tax invoice selection
  currentPrintMode = isTaxInvoice ? 'invoice' : 'receipt';

  // Generate receipt content
  updateReceiptPreview();

  if (isTaxInvoice) {
    // Tax Invoice: Print 1 copy
    window.print();
  } else {
    // Regular receipt: Print 2 copies with cut between
    window.print();
    setTimeout(() => {
      window.print();
    }, 1000);
  }

  // Clear the table
  const list = getOrderList(currentTable, currentTablePart);
  list.length = 0;
  items = list;

  // Reset discounts
  document.getElementById('discountPercent').value = '0';
  document.getElementById('discountAmount').value = '0';

  // Mark table as needing cleaning
  setTableNeedsCleaning(currentTable, true);
  clearTablePax(currentTable);

  // Clear reservation if any
  delete reservations[currentTable];

  renderBillTable();
  updateTableColors();
  saveOrders();
  closePaymentModal();
  closeMenuPopup();

  alert('Payment completed! Table marked for cleaning.');
}
  
function openReservationWizard(t, presetPax = null) {
  if (currentTable !== t) setActiveTable(t, 1);
  else setActiveTable(t, currentTablePart);

  reservationWizardTable = t;
  const existing = reservations[t] || {};
  
  // Determine pax: use presetPax if provided, otherwise use existing reservation pax
  let paxValue = '';
  if (presetPax && presetPax > 0) {
    paxValue = presetPax;
  } else if (Number.isFinite(+existing.pax) && existing.pax > 0) {
    paxValue = parseInt(existing.pax, 10);
  }
  
  reservationWizardDraft = {
    date: String(existing.date || '').trim(),
    time: String(existing.time || '').trim(),
    pax: paxValue,
    menu: String(existing.menu || '').trim(),
    company: String(existing.company || '').trim(),
    name: String(existing.name || '').trim(),
    phone: String(existing.phone || '').trim()
  };

  if (!reservationWizardDraft.date) reservationWizardDraft.date = new Date().toISOString().slice(0, 10);
  // Pax remains empty if not set - user must enter a value

  // Keep dropdowns fresh.
  try { refreshReservationReferenceData(); } catch (e) {}

  setReservationWizardLabels();
  reservationWizardOpenStep('date');
}

function reservationWizardOpenStep(step) {
  hideAllReservationWizardModals();
  setReservationWizardLabels();

  if (!reservationWizardDraft) return;

  if (step === 'date') {
    const dateEl = document.getElementById('resWizDate');
    if (dateEl) dateEl.value = reservationWizardDraft.date || '';
    ensureReservationWizardCalendarBound();
    resWizSyncCalendarToInput();
    const m = document.getElementById('reservationDateModal');
    if (m) m.style.display = 'flex';
    return;
  }

  if (step === 'time') {
    const timeEl = document.getElementById('resWizTime');
    if (timeEl) timeEl.value = reservationWizardDraft.time || '';
    try { makeSelectionOnlyInput(timeEl); } catch {}
    buildResWizTimeGridUI();
    const m = document.getElementById('reservationTimeModal');
    if (m) m.style.display = 'flex';
    try { document.getElementById('resWizTime')?.focus?.(); } catch {}
    return;
  }

  if (step === 'pax') {
    const paxEl = document.getElementById('resWizPax');
    if (paxEl) paxEl.value = String(reservationWizardDraft.pax || '');
    try { makeSelectionOnlyInput(paxEl); } catch {}
    buildResWizPaxPadUI();
    const m = document.getElementById('reservationPaxModal');
    if (m) m.style.display = 'flex';
    try { document.getElementById('resWizPax')?.focus?.(); } catch {}
    return;
  }

  if (step === 'menu') {
    const el = document.getElementById('resWizMenu');
    if (el) el.value = reservationWizardDraft.menu || '';
    ensureResWizMenuAutoAdvanceBound();
    const m = document.getElementById('reservationMenuModal');
    if (m) m.style.display = 'flex';
    try { el?.focus?.(); } catch {}
    return;
  }

  if (step === 'company') {
    const el = document.getElementById('resWizCompany');
    if (el) el.value = reservationWizardDraft.company || '';
    ensureResWizCompanySuggestBound();
    buildResWizCompanySuggestUI();
    const m = document.getElementById('reservationCompanyModal');
    if (m) m.style.display = 'flex';
    try { el?.focus?.(); } catch {}
    return;
  }

  if (step === 'customer') {
    const el = document.getElementById('resWizName');
    if (el) el.value = reservationWizardDraft.name || '';
    ensureResWizCustomerSuggestBound();
    buildResWizCustomerSuggestUI();
    const m = document.getElementById('reservationCustomerModal');
    if (m) m.style.display = 'flex';
    try { el?.focus?.(); } catch {}
    return;
  }

  if (step === 'phone') {
    const el = document.getElementById('resWizPhone');
    if (el) el.value = reservationWizardDraft.phone || '';
    ensureResWizPhoneAutoAdvanceBound();
    const m = document.getElementById('reservationPhoneModal');
    if (m) m.style.display = 'flex';
    try { el?.focus?.(); } catch {}
    return;
  }
}

function reservationWizardBack(step) {
  if (step === 'time') return reservationWizardOpenStep('date');
  if (step === 'pax') return reservationWizardOpenStep('time');
  if (step === 'menu') return reservationWizardOpenStep('pax');
  if (step === 'company') return reservationWizardOpenStep('menu');
  if (step === 'customer') return reservationWizardOpenStep('company');
  if (step === 'phone') return reservationWizardOpenStep('customer');
}

function reservationWizardNext(step) {
  if (!reservationWizardDraft) return;

  if (step === 'date') {
    const date = String(document.getElementById('resWizDate')?.value || '').trim();
    if (!date) { alert('Please select a date.'); return; }
    reservationWizardDraft.date = date;
    return reservationWizardOpenStep('time');
  }

  if (step === 'time') {
    const time = String(document.getElementById('resWizTime')?.value || '').trim();
    if (!time) { alert('Please select a time.'); return; }
    reservationWizardDraft.time = time;
    return reservationWizardOpenStep('pax');
  }

  if (step === 'pax') {
    const pax = parseInt(String(document.getElementById('resWizPax')?.value || '0'), 10);
    if (!Number.isFinite(pax) || pax < 1) { alert('Please enter Pax (1 or more).'); return; }
    reservationWizardDraft.pax = pax;
    return reservationWizardOpenStep('menu');
  }

  if (step === 'menu') {
    reservationWizardDraft.menu = String(document.getElementById('resWizMenu')?.value || '').trim();
    return reservationWizardOpenStep('company');
  }

  if (step === 'company') {
    reservationWizardDraft.company = String(document.getElementById('resWizCompany')?.value || '').trim();
    return reservationWizardOpenStep('customer');
  }

  if (step === 'customer') {
    const name = String(document.getElementById('resWizName')?.value || '').trim();
    if (!name) { alert('Please enter Customer name.'); return; }
    reservationWizardDraft.name = name;
    return reservationWizardOpenStep('phone');
  }
}

function reservationWizardConfirmPax() {
  reservationWizardNext('pax');
}

function reservationWizardFinish() {
  if (!reservationWizardDraft || !reservationWizardTable) return;
  const phone = String(document.getElementById('resWizPhone')?.value || '').trim();
  reservationWizardDraft.phone = phone;

  const { date, time, pax, name, menu, company } = reservationWizardDraft;
  // All fields are optional - no validation required

  // If both pax and menu are specified, pre-populate the order with menu √ó pax
  if (menu && pax > 0) {
    const menuItem = findMenuItemByName(menu);
    if (menuItem) {
      const tableName = reservationWizardTable;
      const list = getOrderList(tableName, 1);
      
      // Add the menu item with qty = pax
      list.push({
        nameKo: menuItem.korean || menuItem.english || menu,
        nameEn: menuItem.english || menuItem.korean || menu,
        qty: pax,
        unit: menuItem.price || 0,
        total: pax * (menuItem.price || 0)
      });
      
      // Set pax for default quantity on future items
      setTablePax(tableName, pax);
      
      saveOrders();
    }
  }

  // Try to persist to backend if available, so reservations created/edited
  // from anywhere (admin page, other devices) show up on the POS table map.
  (async () => {
    try {
      if (typeof apiPost !== 'function') throw new Error('backend unavailable');

      const existingId = String(reservations?.[reservationWizardTable]?.id || '').trim();
      const payload = {
        table: reservationWizardTable,
        date,
        time,
        pax,
        menu: menu || '',
        companyName: company || '',
        customerName: name,
        phone: phone || ''
      };

      if (existingId && typeof apiPut === 'function') {
        await apiPut(`/reservations/${encodeURIComponent(existingId)}`, payload);
      } else {
        await apiPost('/reservations', payload);
      }

      // Reservation starts as not occupied until arrived.
      setTableOccupiedOverride(reservationWizardTable, false);

      // Reload today‚Äôs backend reservations (source of truth for table status).
      if (typeof loadReservationsFromBackend === 'function') {
        await loadReservationsFromBackend();
      } else {
        updateTableColors();
      }
    } catch (e) {
      // Fallback: keep local-only reservation if backend isn't available.
      reservations[reservationWizardTable] = {
        name,
        company: company || '',
        phone: phone || '',
        date,
        time,
        pax,
        menu: menu || ''
      };

      setTableOccupiedOverride(reservationWizardTable, false);
      updateTableColors();
    } finally {
      // Persist suggestion lists
      try {
        addToStringArrayLS(RES_REF_KEYS.customers, name);
        if (company) addToStringArrayLS(RES_REF_KEYS.companies, company);
        if (menu) addToStringArrayLS(RES_REF_KEYS.menus, menu);
        if (phone) addToStringArrayLS(RES_REF_KEYS.phones, phone);
        refreshReservationReferenceData();
      } catch {}

      closeReservationWizard();
    }
  })();

  return;
}

// Helper function to find a menu item by name (matches english or korean)
function findMenuItemByName(menuName) {
  if (!menuName || !Array.isArray(menuItems)) return null;
  const searchName = String(menuName).trim().toLowerCase();
  
  // Exact match first
  for (const m of menuItems) {
    const eng = String(m?.english || '').trim().toLowerCase();
    const kor = String(m?.korean || '').trim().toLowerCase();
    if (eng === searchName || kor === searchName) {
      return m;
    }
  }
  
  // Partial match fallback
  for (const m of menuItems) {
    const eng = String(m?.english || '').trim().toLowerCase();
    const kor = String(m?.korean || '').trim().toLowerCase();
    if (eng.includes(searchName) || kor.includes(searchName) || 
        searchName.includes(eng) || searchName.includes(kor)) {
      return m;
    }
  }
  
  return null;
}

/* --------------------------------------------------
   RESERVATION FIELD UX (calendar button, time grid, pax pad, dropdown lists)
-------------------------------------------------- */
const RES_REF_KEYS = {
  customers: 'reservationRefCustomers',
  companies: 'reservationRefCompanies',
  menus: 'reservationRefMenus',
  phones: 'reservationRefPhones'
};

function readStringArrayFromLS(key) {
  try {
    const raw = localStorage.getItem(key);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) return [];
    return parsed.map(v => String(v || '').trim()).filter(Boolean);
  } catch {
    return [];
  }
}

function writeStringArrayToLS(key, list) {
  try {
    const clean = (Array.isArray(list) ? list : [])
      .map(v => String(v || '').trim())
      .filter(Boolean);
    const uniq = Array.from(new Set(clean)).slice(0, 80);
    localStorage.setItem(key, JSON.stringify(uniq));
  } catch {}
}

function addToStringArrayLS(key, value) {
  const v = String(value || '').trim();
  if (!v) return;
  const current = readStringArrayFromLS(key);
  const next = [v, ...current.filter(x => x !== v)].slice(0, 80);
  writeStringArrayToLS(key, next);
}

function populateDatalist(datalistId, values) {
  const dl = document.getElementById(datalistId);
  if (!dl) return;
  if (dl.replaceChildren) dl.replaceChildren();
  else dl.innerHTML = '';

  const frag = document.createDocumentFragment();
  for (const v of (Array.isArray(values) ? values : [])) {
    const opt = document.createElement('option');
    opt.value = v;
    frag.appendChild(opt);
  }
  dl.appendChild(frag);
}

function populateSelect(selectId, values, opts = {}) {
  const el = document.getElementById(selectId);
  if (!el || String(el.tagName || '').toUpperCase() !== 'SELECT') return;

  const allowBlank = opts.allowBlank !== false;
  const blankLabel = String(opts.blankLabel || '‚Äî Select ‚Äî');
  const prev = String(el.value || '').trim();

  if (el.replaceChildren) el.replaceChildren();
  else el.innerHTML = '';

  const frag = document.createDocumentFragment();
  if (allowBlank) {
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = blankLabel;
    frag.appendChild(opt);
  }

  for (const v of (Array.isArray(values) ? values : [])) {
    const label = String(v || '').trim();
    if (!label) continue;
    const opt = document.createElement('option');
    opt.value = label;
    opt.textContent = label;
    frag.appendChild(opt);
  }
  el.appendChild(frag);

  // Preserve current value when possible.
  if (prev && Array.from(el.options || []).some(o => o.value === prev)) {
    el.value = prev;
  } else if (!allowBlank) {
    // Force a valid selection when blank isn't allowed.
    const first = el.options && el.options.length ? el.options[0].value : '';
    el.value = first;
  } else {
    el.value = '';
  }
}

function makeSelectionOnlyInput(input) {
  if (!input || input.dataset?.selectionOnly) return;
  try { input.readOnly = true; } catch {}
  try { input.inputMode = 'none'; } catch {}

  const block = (e) => {
    const k = e.key;
    if (!k) return;
    // Allow navigation keys.
    if (k === 'Tab' || k === 'Escape' || k === 'Enter' || k.startsWith('Arrow')) return;
    if (k === 'Home' || k === 'End' || k === 'PageUp' || k === 'PageDown') return;

    // Block any text editing.
    if (k.length === 1 || k === 'Backspace' || k === 'Delete') {
      e.preventDefault();
      e.stopPropagation();
    }
  };

  input.addEventListener('keydown', block);
  input.addEventListener('paste', (e) => { e.preventDefault(); e.stopPropagation(); });
  input.addEventListener('cut', (e) => { e.preventDefault(); e.stopPropagation(); });
  input.addEventListener('drop', (e) => { e.preventDefault(); e.stopPropagation(); });
  input.dataset.selectionOnly = '1';
}

async function fetchReservationOptionsFromBackend() {
  // Optional fallback backend integration.
  // Primary path uses same-origin /api/* via apiGet when available.
  const base = (window.POS_BACKEND_URL || '').toString().trim();
  if (!base) return null;

  const url = base.replace(/\/$/, '') + '/reservation-options';
  try {
    const controller = new AbortController();
    const t = setTimeout(() => controller.abort(), 1500);
    const res = await fetch(url, { signal: controller.signal, cache: 'no-store' });
    clearTimeout(t);
    if (!res.ok) return null;
    const json = await res.json();
    return {
      customers: Array.isArray(json?.customers) ? json.customers : [],
      companies: Array.isArray(json?.companies) ? json.companies : [],
      menus: Array.isArray(json?.menus) ? json.menus : [],
      phones: Array.isArray(json?.phones) ? json.phones : []
    };
  } catch {
    return null;
  }
}

let reservationRefCache = { customers: [], companies: [], menus: [], phones: [] };

function buildUpcomingDateList(days = 60) {
  const out = [];
  const base = new Date();
  for (let i = 0; i < days; i++) {
    const d = new Date(base.getFullYear(), base.getMonth(), base.getDate() + i);
    // Local ISO date (avoid UTC shift)
    const off = d.getTimezoneOffset() * 60000;
    const iso = new Date(d.getTime() - off).toISOString().slice(0, 10);
    out.push(iso);
  }
  return out;
}

function buildTimeOptions(stepMinutes = 10) {
  const out = [];
  for (let mins = 0; mins < 24 * 60; mins += stepMinutes) {
    out.push(formatTimeHHMM(mins));
  }
  return out;
}

function buildPaxOptions(max = 30) {
  const out = [];
  for (let i = 1; i <= max; i++) out.push(String(i));
  return out;
}

/* --------------------------------------------------
   QUICK ADD CUSTOMER / COMPANY POPUPS
-------------------------------------------------- */
function showQuickAddCustomerPopup() {
  const popup = document.getElementById('quickAddCustomerPopup');
  if (!popup) return;
  
  // Clear form
  document.getElementById('quickCustomerName').value = '';
  document.getElementById('quickCustomerPhone').value = '';
  document.getElementById('quickCustomerEmail').value = '';
  document.getElementById('quickCustomerNotes').value = '';
  
  popup.style.display = 'flex';
  document.getElementById('quickCustomerName').focus();
}

function closeQuickAddCustomerPopup() {
  const popup = document.getElementById('quickAddCustomerPopup');
  if (popup) popup.style.display = 'none';
}

async function saveQuickCustomer() {
  const name = document.getElementById('quickCustomerName').value.trim();
  const phone = document.getElementById('quickCustomerPhone').value.trim();
  const email = document.getElementById('quickCustomerEmail').value.trim();
  const notes = document.getElementById('quickCustomerNotes').value.trim();
  
  if (!name) {
    alert('Please enter a customer name.');
    return;
  }
  
  try {
    const response = await fetch('/api/customers', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, phone, email, notes })
    });
    
    if (!response.ok) {
      throw new Error(await response.text());
    }
    
    // Refresh the reservation dropdown lists
    await refreshReservationReferenceData();
    
    // Set the newly added customer in the input field
    const resWizNameInput = document.getElementById('resWizName');
    if (resWizNameInput) resWizNameInput.value = name;
    
    closeQuickAddCustomerPopup();
    alert('Customer "' + name + '" added successfully!');
  } catch (err) {
    alert('Failed to add customer: ' + err.message);
  }
}

function showQuickAddCompanyPopup() {
  const popup = document.getElementById('quickAddCompanyPopup');
  if (!popup) return;
  
  // Clear form
  document.getElementById('quickCompanyName').value = '';
  document.getElementById('quickCompanyContact').value = '';
  document.getElementById('quickCompanyPhone').value = '';
  document.getElementById('quickCompanyTaxId').value = '';
  document.getElementById('quickCompanyAddress').value = '';
  
  popup.style.display = 'flex';
  document.getElementById('quickCompanyName').focus();
}

function closeQuickAddCompanyPopup() {
  const popup = document.getElementById('quickAddCompanyPopup');
  if (popup) popup.style.display = 'none';
}

function showQuickAddMenuPopup() {
  const popup = document.getElementById('quickAddMenuPopup');
  if (popup) {
    popup.style.display = 'flex';
    document.getElementById('quickMenuName').value = '';
    document.getElementById('quickMenuPrice').value = '';
    document.getElementById('quickMenuName').focus();
  }
}

function closeQuickAddMenuPopup() {
  const popup = document.getElementById('quickAddMenuPopup');
  if (popup) popup.style.display = 'none';
}

async function saveQuickMenu() {
  const nameField = document.getElementById('quickMenuName').value.trim();
  const price = parseFloat(document.getElementById('quickMenuPrice').value) || 0;
  
  if (!nameField) {
    alert('Please enter a menu name.');
    return;
  }
  
  // Parse 2-line format: line 1 = English, line 2 = Korean
  const lines = nameField.split('\n').map(l => l.trim()).filter(Boolean);
  const english = lines[0] || '';
  const korean = lines[1] || '';
  
  try {
    const response = await fetch('/api/menu', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: english, english, korean, price })
    });
    
    if (!response.ok) {
      throw new Error(await response.text());
    }
    
    // Update local menuItems array
    menuItems.push({ english, korean, price });
    
    // Refresh the reservation dropdown lists
    await refreshReservationReferenceData();
    
    // Set the newly added menu in the input field
    const resWizMenuInput = document.getElementById('resWizMenu');
    if (resWizMenuInput) resWizMenuInput.value = english || korean;
    
    closeQuickAddMenuPopup();
    alert('Menu "' + (english || korean) + '" added successfully!');
  } catch (err) {
    alert('Failed to add menu: ' + err.message);
  }
}

async function saveQuickCompany() {
  const name = document.getElementById('quickCompanyName').value.trim();
  const contact = document.getElementById('quickCompanyContact').value.trim();
  const phone = document.getElementById('quickCompanyPhone').value.trim();
  const taxId = document.getElementById('quickCompanyTaxId').value.trim();
  const address = document.getElementById('quickCompanyAddress').value.trim();
  
  if (!name) {
    alert('Please enter a company name.');
    return;
  }
  
  try {
    const response = await fetch('/api/companies', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, contact, phone, taxId, address })
    });
    
    if (!response.ok) {
      throw new Error(await response.text());
    }
    
    // Refresh the reservation dropdown lists
    await refreshReservationReferenceData();
    
    // Set the newly added company in the input field
    const resWizCompanyInput = document.getElementById('resWizCompany');
    if (resWizCompanyInput) resWizCompanyInput.value = name;
    
    closeQuickAddCompanyPopup();
    alert('Company "' + name + '" added successfully!');
  } catch (err) {
    alert('Failed to add company: ' + err.message);
  }
}

async function refreshReservationReferenceData() {
  const localCustomers = readStringArrayFromLS(RES_REF_KEYS.customers);
  const localCompanies = readStringArrayFromLS(RES_REF_KEYS.companies);
  const localMenus = readStringArrayFromLS(RES_REF_KEYS.menus);
  const localPhones = readStringArrayFromLS(RES_REF_KEYS.phones);

  // Also seed menus from the existing POS menu items.
  const seededMenus = [];
  try {
    if (Array.isArray(menuItems)) {
      for (const m of menuItems) {
        const label = String(m?.english || m?.korean || '').trim();
        if (label) seededMenus.push(label);
      }
    }
  } catch {}

  // Prefer same-origin backend if available.
  let backend = null;
  try {
    if (typeof apiGet === 'function') {
      const [cust, comp, menu] = await Promise.all([
        apiGet('/customers'),
        apiGet('/companies'),
        apiGet('/menu')
      ]);
      backend = {
        customers: (cust?.items || []).map(c => String(c?.name || '').trim()).filter(Boolean),
        companies: (comp?.items || []).map(c => String(c?.name || '').trim()).filter(Boolean),
        menus: (menu?.items || []).map(m => String(m?.name || '').trim()).filter(Boolean),
        phones: (cust?.items || []).map(c => String(c?.phone || '').trim()).filter(Boolean)
      };
    }
  } catch (e) {
    backend = null;
  }

  if (!backend) backend = await fetchReservationOptionsFromBackend();
  const merged = {
    customers: [...(backend?.customers || []), ...localCustomers],
    companies: [...(backend?.companies || []), ...localCompanies],
    menus: [...(backend?.menus || []), ...localMenus, ...seededMenus],
    phones: [...(backend?.phones || []), ...localPhones]
  };

  reservationRefCache = {
    customers: Array.from(new Set(merged.customers.map(v => String(v || '').trim()).filter(Boolean))).slice(0, 80),
    companies: Array.from(new Set(merged.companies.map(v => String(v || '').trim()).filter(Boolean))).slice(0, 80),
    menus: Array.from(new Set(merged.menus.map(v => String(v || '').trim()).filter(Boolean))).slice(0, 120),
    phones: Array.from(new Set(merged.phones.map(v => String(v || '').trim()).filter(Boolean))).slice(0, 120)
  };

  populateDatalist('reserveCustomerList', reservationRefCache.customers);
  populateDatalist('reserveCompanyList', reservationRefCache.companies);
  populateDatalist('reserveMenuList', reservationRefCache.menus);
  populateDatalist('reservePhoneList', reservationRefCache.phones);

  // Selection-only dropdowns (POS UI uses <select> for these fields).
  populateSelect('reserveName', reservationRefCache.customers, { allowBlank: false, blankLabel: 'Select customer' });
  populateSelect('resWizName', reservationRefCache.customers, { allowBlank: false, blankLabel: 'Select customer' });
  populateSelect('reserveCompany', reservationRefCache.companies, { allowBlank: true, blankLabel: '‚Äî Company (optional) ‚Äî' });
  populateSelect('resWizCompany', reservationRefCache.companies, { allowBlank: true, blankLabel: '‚Äî Company (optional) ‚Äî' });
  populateSelect('reserveMenu', reservationRefCache.menus, { allowBlank: true, blankLabel: '‚Äî Menu (optional) ‚Äî' });
  populateSelect('resWizMenu', reservationRefCache.menus, { allowBlank: true, blankLabel: '‚Äî Menu (optional) ‚Äî' });
  populateSelect('reservePhone', reservationRefCache.phones, { allowBlank: true, blankLabel: '‚Äî Phone (optional) ‚Äî' });
  populateSelect('resWizPhone', reservationRefCache.phones, { allowBlank: true, blankLabel: '‚Äî Phone (optional) ‚Äî' });

  // Static dropdown lists for date/time/pax.
  populateDatalist('reserveDateList', buildUpcomingDateList(60));
  populateDatalist('reserveTimeList', buildTimeOptions(10));
  populateDatalist('reservePaxList', buildPaxOptions(30));
}

function safeShowPicker(inputEl) {
  if (!inputEl) return;
  try {
    if (typeof inputEl.showPicker === 'function') {
      inputEl.showPicker();
      return;
    }
  } catch {}
  try { inputEl.focus(); } catch {}
}

function formatTimeHHMM(totalMinutes) {
  const h = Math.floor(totalMinutes / 60);
  const m = totalMinutes % 60;
  return String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
}

function buildTimeGridUI() {
  const grid = document.getElementById('reserveTimeGrid');
  const input = document.getElementById('reserveTime');
  const dateInput = document.getElementById('reserveDate');
  if (!grid || !input) return;

  // Always rebuild to filter based on selected date
  grid.innerHTML = '';
  grid.dataset.built = '1';

  const selectedDate = String(dateInput?.value || '').trim();
  const today = new Date().toISOString().slice(0, 10);
  const isToday = selectedDate === today || !selectedDate;
  const now = new Date();
  const currentMinutes = isToday ? (now.getHours() * 60 + now.getMinutes()) : -1;

  const frag = document.createDocumentFragment();
  for (let mins = 0; mins < 24 * 60; mins += 10) {
    // Skip past times if today
    if (isToday && mins <= currentMinutes) continue;
    
    const t = formatTimeHHMM(mins);
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'time-btn';
    btn.textContent = t;
    btn.dataset.time = t;
    frag.appendChild(btn);
  }
  grid.appendChild(frag);

  function syncSelected() {
    const v = String(input.value || '').trim();
    grid.querySelectorAll('.time-btn.selected').forEach(b => b.classList.remove('selected'));
    if (!v) return;
    const match = grid.querySelector(`.time-btn[data-time="${CSS.escape(v)}"]`);
    if (match) match.classList.add('selected');
  }

  grid.addEventListener('click', (e) => {
    const btn = e.target.closest('.time-btn');
    if (!btn) return;
    const t = btn.dataset.time;
    if (!t) return;
    input.value = t;
    syncSelected();
  });

  input.addEventListener('change', syncSelected);
  input.addEventListener('input', syncSelected);
  syncSelected();
}

function buildPaxPadUI() {
  const pad = document.getElementById('reservePaxPad');
  const input = document.getElementById('reservePax');
  if (!pad || !input) return;
  if (pad.dataset.built) return;
  pad.dataset.built = '1';

  const keys = ['1','2','3','4','5','6','7','8','9','Clear','0','‚å´'];
  const frag = document.createDocumentFragment();
  for (const k of keys) {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'num-btn' + ((k === 'Clear' || k === '‚å´') ? ' utility' : '');
    btn.textContent = k;
    btn.dataset.key = k;
    frag.appendChild(btn);
  }
  pad.appendChild(frag);

  pad.addEventListener('click', (e) => {
    const btn = e.target.closest('button[data-key]');
    if (!btn) return;
    const key = btn.dataset.key;
    let cur = String(input.value || '').replace(/\D+/g, '');

    if (key === 'Clear') {
      input.value = '';
      input.focus();
      return;
    }
    if (key === '‚å´') {
      cur = cur.slice(0, -1);
      input.value = cur;
      input.focus();
      return;
    }

    if (!/^[0-9]$/.test(key)) return;

    // Prevent leading zeros
    if (!cur && key === '0') return;
    const next = (cur + key).slice(0, 3);
    input.value = next;
    input.focus();
  });
}

(function initReservationFieldUX() {
  const popup = document.getElementById('reservationPopup');
  if (!popup || popup.dataset.fieldUxBound) return;

  const timeBtn = document.getElementById('reserveTimePickerBtn');
  const timeEl = document.getElementById('reserveTime');
  const paxConfirmBtn = document.getElementById('reservePaxConfirmBtn');
  const menuEl = document.getElementById('reserveMenu');

  // No free typing: time/pax are set via picker/grid/pad.
  try { makeSelectionOnlyInput(timeEl); } catch {}
  try { makeSelectionOnlyInput(document.getElementById('reservePax')); } catch {}

  if (timeBtn && timeEl) {
    timeBtn.addEventListener('click', (e) => {
      e.preventDefault();
      safeShowPicker(timeEl);
    });
  }

  // Build rich UI components once.
  buildTimeGridUI();
  buildPaxPadUI();

  if (paxConfirmBtn) {
    paxConfirmBtn.addEventListener('click', (e) => {
      e.preventDefault();
      const paxEl = document.getElementById('reservePax');
      const pax = parseInt(String(paxEl?.value || '0'), 10);
      if (!Number.isFinite(pax) || pax < 1) {
        try { paxEl?.focus?.(); } catch {}
        alert('Please enter Pax (1 or more).');
        return;
      }
      // Pax is the 3rd step in the slider, but we advance relative to current position.
      setReservationSlide(reservationSlideIndex + 1);
    });
  }

  // Load dropdowns (from backend if configured, else localStorage/menuItems).
  refreshReservationReferenceData();

  // Auto-advance when menu is chosen/entered
  if (menuEl) {
    const autoNext = () => {
      const v = String(menuEl.value || '').trim();
      if (!v) return;
      // Menu step is slide 3 (0=Date,1=Time,2=Pax,3=Menu)
      if (typeof reservationSlideIndex === 'number' && reservationSlideIndex === 3) {
        setReservationSlide(4);
      }
    };
    menuEl.addEventListener('change', autoNext);
    menuEl.addEventListener('blur', autoNext);
  }

  popup.dataset.fieldUxBound = '1';
})();

/* Reservation slider controller */
let reservationSlideIndex = 0;

function getReservationSlidesCount() {
  const track = document.getElementById('reservationTrack');
  return track ? track.children.length : 0;
}

function setReservationSlide(index) {
  const track = document.getElementById('reservationTrack');
  const nextBtn = document.getElementById('reservationNextBtn');
  const prevBtn = document.getElementById('reservationPrevBtn');
  const submitBtn = document.getElementById('reservationSubmitBtn');
  if (!track) return;

  const count = getReservationSlidesCount();
  if (count <= 0) return;

  reservationSlideIndex = Math.max(0, Math.min(count - 1, index));
  track.style.transform = `translateX(-${reservationSlideIndex * 100}%)`;

  const isLast = reservationSlideIndex === count - 1;
  const isFirst = reservationSlideIndex === 0;
  if (nextBtn) nextBtn.style.display = isLast ? 'none' : 'inline-flex';
  if (prevBtn) prevBtn.style.display = isFirst ? 'none' : 'inline-flex';
  if (submitBtn) submitBtn.style.display = isLast ? 'inline-flex' : 'none';

  // Focus the first meaningful control in the current slide
  const slide = track.children[reservationSlideIndex];
  const focusEl = slide
    ? (slide.querySelector('input:not(.visually-hidden):not([type="hidden"]),select,textarea,button')
      || slide.querySelector('button')
      || slide.querySelector('input,select,textarea'))
    : null;
  if (focusEl && typeof focusEl.focus === 'function') {
    setTimeout(() => focusEl.focus(), 0);
  }
}

function advanceReservationSlide() {
  const track = document.getElementById('reservationTrack');
  if (!track) return;
  // No validation - all fields are optional, just advance to next slide
  setReservationSlide(reservationSlideIndex + 1);
}

/* Always-visible calendar for reservation date */
let reservationCalYear = null;
let reservationCalMonth = null; // 0-11

function pad2(n) {
  return String(n).padStart(2, '0');
}

function toISODate(d) {
  return d.getFullYear() + '-' + pad2(d.getMonth() + 1) + '-' + pad2(d.getDate());
}

function monthLabel(year, monthIndex) {
  const months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  return months[monthIndex] + ' ' + year;
}

function renderReservationCalendar() {
  const grid = document.getElementById('reserveCalGrid');
  const label = document.getElementById('reserveCalLabel');
  const input = document.getElementById('reserveDate');
  if (!grid || !label || !input) return;

  if (typeof reservationCalYear !== 'number' || typeof reservationCalMonth !== 'number') {
    const base = input.value ? new Date(input.value + 'T00:00:00') : new Date();
    reservationCalYear = base.getFullYear();
    reservationCalMonth = base.getMonth();
  }

  label.textContent = monthLabel(reservationCalYear, reservationCalMonth);

  const selected = String(input.value || '').trim();
  const todayStr = toISODate(new Date());

  // Start from the Sunday before (or on) the first day of the month.
  const first = new Date(reservationCalYear, reservationCalMonth, 1);
  const start = new Date(first);
  start.setDate(first.getDate() - first.getDay());

  if (grid.replaceChildren) grid.replaceChildren();
  else grid.innerHTML = '';

  const frag = document.createDocumentFragment();
  for (let i = 0; i < 42; i++) {
    const d = new Date(start);
    d.setDate(start.getDate() + i);
    const iso = toISODate(d);
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'cal-day';
    btn.textContent = String(d.getDate());
    btn.dataset.date = iso;

    if (d.getMonth() !== reservationCalMonth) btn.classList.add('other');
    if (iso === todayStr) btn.classList.add('today');
    if (selected && iso === selected) btn.classList.add('selected');

    frag.appendChild(btn);
  }
  grid.appendChild(frag);
}

function setReservationCalendarMonth(delta) {
  if (typeof reservationCalYear !== 'number' || typeof reservationCalMonth !== 'number') {
    reservationCalYear = new Date().getFullYear();
    reservationCalMonth = new Date().getMonth();
  }
  const d = new Date(reservationCalYear, reservationCalMonth + delta, 1);
  reservationCalYear = d.getFullYear();
  reservationCalMonth = d.getMonth();
  renderReservationCalendar();
}

function syncReservationCalendarToInput() {
  const input = document.getElementById('reserveDate');
  if (!input) return;
  const v = String(input.value || '').trim();
  if (!v) return;
  const d = new Date(v + 'T00:00:00');
  if (!Number.isFinite(d.getTime())) return;
  reservationCalYear = d.getFullYear();
  reservationCalMonth = d.getMonth();
  renderReservationCalendar();
}

/* Reservation Wizard Calendar (separate IDs) */
let resWizCalYear = null;
let resWizCalMonth = null;

function resWizMonthLabel(year, monthIndex) {
  const months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  return months[monthIndex] + ' ' + year;
}

function resWizToISODate(d) {
  return d.getFullYear() + '-' + pad2(d.getMonth() + 1) + '-' + pad2(d.getDate());
}

function resWizRenderCalendar() {
  const grid = document.getElementById('resWizCalGrid');
  const label = document.getElementById('resWizCalLabel');
  const input = document.getElementById('resWizDate');
  if (!grid || !label || !input) return;

  if (typeof resWizCalYear !== 'number' || typeof resWizCalMonth !== 'number') {
    const base = input.value ? new Date(input.value + 'T00:00:00') : new Date();
    resWizCalYear = base.getFullYear();
    resWizCalMonth = base.getMonth();
  }

  label.textContent = resWizMonthLabel(resWizCalYear, resWizCalMonth);
  const selected = String(input.value || '').trim();
  const todayStr = resWizToISODate(new Date());

  const first = new Date(resWizCalYear, resWizCalMonth, 1);
  const start = new Date(first);
  start.setDate(first.getDate() - first.getDay());

  if (grid.replaceChildren) grid.replaceChildren();
  else grid.innerHTML = '';

  const frag = document.createDocumentFragment();
  for (let i = 0; i < 42; i++) {
    const d = new Date(start);
    d.setDate(start.getDate() + i);
    const iso = resWizToISODate(d);
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'cal-day';
    btn.textContent = String(d.getDate());
    btn.dataset.date = iso;
    if (d.getMonth() !== resWizCalMonth) btn.classList.add('other');
    if (iso === todayStr) btn.classList.add('today');
    if (selected && iso === selected) btn.classList.add('selected');
    frag.appendChild(btn);
  }
  grid.appendChild(frag);
}

function resWizSetCalendarMonth(delta) {
  if (typeof resWizCalYear !== 'number' || typeof resWizCalMonth !== 'number') {
    resWizCalYear = new Date().getFullYear();
    resWizCalMonth = new Date().getMonth();
  }
  const d = new Date(resWizCalYear, resWizCalMonth + delta, 1);
  resWizCalYear = d.getFullYear();
  resWizCalMonth = d.getMonth();
  resWizRenderCalendar();
}

function resWizSyncCalendarToInput() {
  const input = document.getElementById('resWizDate');
  if (!input) return;
  const v = String(input.value || '').trim();
  if (!v) return;
  const d = new Date(v + 'T00:00:00');
  if (!Number.isFinite(d.getTime())) return;
  resWizCalYear = d.getFullYear();
  resWizCalMonth = d.getMonth();
  resWizRenderCalendar();
}

function ensureReservationWizardCalendarBound() {
  const modal = document.getElementById('reservationDateModal');
  const grid = document.getElementById('resWizCalGrid');
  const prev = document.getElementById('resWizCalPrev');
  const next = document.getElementById('resWizCalNext');
  const input = document.getElementById('resWizDate');
  if (!modal || !grid || !prev || !next || !input) return;
  if (modal.dataset.bound) return;

  prev.addEventListener('click', (e) => {
    e.preventDefault();
    resWizSetCalendarMonth(-1);
  });
  next.addEventListener('click', (e) => {
    e.preventDefault();
    resWizSetCalendarMonth(1);
  });

  grid.addEventListener('click', (e) => {
    const btn = e.target.closest('button[data-date]');
    if (!btn) return;
    const iso = String(btn.dataset.date || '').trim();
    if (!iso) return;
    const d = new Date(iso + 'T00:00:00');
    if (Number.isFinite(d.getTime())) {
      resWizCalYear = d.getFullYear();
      resWizCalMonth = d.getMonth();
    }
    input.value = iso;
    resWizRenderCalendar();

    // Auto-advance to Time once a date is chosen.
    try {
      reservationWizardDraft && (reservationWizardDraft.date = iso);
      setTimeout(() => reservationWizardOpenStep('time'), 0);
    } catch {}
  });

  input.addEventListener('change', () => {
    resWizSyncCalendarToInput();
  });

  modal.dataset.bound = '1';
}

/* Reservation Wizard Time Grid */
function buildResWizTimeGridUI() {
  const grid = document.getElementById('resWizTimeGrid');
  const input = document.getElementById('resWizTime');
  const btn = document.getElementById('resWizTimePickerBtn');
  if (!grid || !input) return;

  // Always rebuild to filter based on selected date
  grid.innerHTML = '';
  grid.dataset.built = '1';
  
  const selectedDate = String(reservationWizardDraft?.date || '').trim();
  const today = new Date().toISOString().slice(0, 10);
  const isToday = selectedDate === today || !selectedDate;
  const now = new Date();
  const currentMinutes = isToday ? (now.getHours() * 60 + now.getMinutes()) : -1;

  const frag = document.createDocumentFragment();
  for (let mins = 0; mins < 24 * 60; mins += 10) {
    // Skip past times if today
    if (isToday && mins <= currentMinutes) continue;
    
    const t = formatTimeHHMM(mins);
    const b = document.createElement('button');
    b.type = 'button';
    b.className = 'time-btn';
    b.textContent = t;
    b.dataset.time = t;
    frag.appendChild(b);
  }
  grid.appendChild(frag);

  grid.addEventListener('click', (e) => {
    const b = e.target.closest('.time-btn');
    if (!b) return;
    const t = b.dataset.time;
    if (!t) return;
    input.value = t;
    resWizSyncTimeSelected();
    // Auto-advance to Pax
    try {
      reservationWizardDraft && (reservationWizardDraft.time = t);
      setTimeout(() => reservationWizardOpenStep('pax'), 0);
    } catch {}
  });

  input.addEventListener('change', resWizSyncTimeSelected);
  input.addEventListener('input', resWizSyncTimeSelected);

  if (btn && !btn.dataset.bound) {
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      safeShowPicker(input);
    });
    btn.dataset.bound = '1';
  }

  resWizSyncTimeSelected();
}

function resWizSyncTimeSelected() {
  const grid = document.getElementById('resWizTimeGrid');
  const input = document.getElementById('resWizTime');
  if (!grid || !input) return;
  const v = String(input.value || '').trim();
  grid.querySelectorAll('.time-btn.selected').forEach(b => b.classList.remove('selected'));
  if (!v) return;
  const match = grid.querySelector(`.time-btn[data-time="${CSS.escape(v)}"]`);
  if (match) match.classList.add('selected');
}

/* Reservation Wizard Pax Pad */
function buildResWizPaxPadUI() {
  const pad = document.getElementById('resWizPaxPad');
  const input = document.getElementById('resWizPax');
  if (!pad || !input) return;
  if (pad.dataset.built) return;
  pad.dataset.built = '1';

  const keys = ['1','2','3','4','5','6','7','8','9','Clear','0','‚å´'];
  const frag = document.createDocumentFragment();
  for (const k of keys) {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'num-btn' + ((k === 'Clear' || k === '‚å´') ? ' utility' : '');
    btn.textContent = k;
    btn.dataset.key = k;
    frag.appendChild(btn);
  }
  pad.appendChild(frag);

  pad.addEventListener('click', (e) => {
    const btn = e.target.closest('button[data-key]');
    if (!btn) return;
    const key = btn.dataset.key;
    let cur = String(input.value || '').replace(/\D+/g, '');

    if (key === 'Clear') {
      input.value = '';
      try { input.focus(); } catch {}
      return;
    }
    if (key === '‚å´') {
      cur = cur.slice(0, -1);
      input.value = cur;
      try { input.focus(); } catch {}
      return;
    }

    if (!/^[0-9]$/.test(key)) return;
    if (!cur && key === '0') return;
    const next = (cur + key).slice(0, 3);
    input.value = next;
    try { input.focus(); } catch {}
  });
}

/* Reservation Wizard Company/Customer suggestion dropdowns */
function buildResWizSuggestUI({ inputId, listId, values, onPick }) {
  const input = document.getElementById(inputId);
  const list = document.getElementById(listId);
  if (!input || !list) return;

  const q = String(input.value || '').trim().toLowerCase();
  const source = Array.isArray(values) ? values : [];
  const filtered = (q
    ? source.filter(v => String(v || '').toLowerCase().includes(q))
    : source
  ).slice(0, 18);

  if (list.replaceChildren) list.replaceChildren();
  else list.innerHTML = '';

  if (!filtered.length) {
    const empty = document.createElement('div');
    empty.className = 'suggest-empty';
    empty.textContent = q ? 'No matches' : 'No suggestions yet';
    list.appendChild(empty);
    return;
  }

  const frag = document.createDocumentFragment();
  for (const v of filtered) {
    const label = String(v || '').trim();
    if (!label) continue;
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'suggest-btn';
    btn.textContent = label;
    btn.dataset.value = label;
    frag.appendChild(btn);
  }
  list.appendChild(frag);

  if (!list.dataset.bound) {
    list.addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-value]');
      if (!btn) return;
      const v = String(btn.dataset.value || '').trim();
      if (!v) return;
      input.value = v;
      try { input.focus(); } catch {}
      try { onPick && onPick(v); } catch {}
      // keep list in sync with the chosen value
      try { buildResWizSuggestUI({ inputId, listId, values, onPick }); } catch {}
    });
    list.dataset.bound = '1';
  }
}

function buildResWizCompanySuggestUI() {
  buildResWizSuggestUI({
    inputId: 'resWizCompany',
    listId: 'resWizCompanySuggest',
    values: reservationRefCache?.companies || [],
    onPick: (v) => {
      if (reservationWizardDraft) reservationWizardDraft.company = v;
      // Auto-advance to Customer when a company is picked.
      try { setTimeout(() => reservationWizardOpenStep('customer'), 0); } catch {}
    }
  });
}

function buildResWizCustomerSuggestUI() {
  buildResWizSuggestUI({
    inputId: 'resWizName',
    listId: 'resWizCustomerSuggest',
    values: reservationRefCache?.customers || [],
    onPick: (v) => {
      if (reservationWizardDraft) reservationWizardDraft.name = v;
      // Auto-advance to Phone when a customer is picked.
      try { setTimeout(() => reservationWizardOpenStep('phone'), 0); } catch {}
    }
  });
}

function ensureResWizCompanySuggestBound() {
  const input = document.getElementById('resWizCompany');
  if (!input || input.dataset.suggestBound) return;
  const rerender = () => buildResWizCompanySuggestUI();
  input.addEventListener('input', rerender);
  input.addEventListener('focus', rerender);
  input.addEventListener('change', () => {
    const v = String(input.value || '').trim();
    if (reservationWizardDraft) reservationWizardDraft.company = v;
    // Company is optional; auto-advance when user sets or clears it.
    try { setTimeout(() => reservationWizardOpenStep('customer'), 0); } catch {}
  });
  input.addEventListener('keydown', (e) => {
    if (e.key !== 'Enter') return;
    e.preventDefault();
    reservationWizardNext('company');
  });
  input.dataset.suggestBound = '1';
}

function ensureResWizCustomerSuggestBound() {
  const input = document.getElementById('resWizName');
  if (!input || input.dataset.suggestBound) return;
  const rerender = () => buildResWizCustomerSuggestUI();
  input.addEventListener('input', rerender);
  input.addEventListener('focus', rerender);
  input.addEventListener('change', () => {
    const v = String(input.value || '').trim();
    if (!v) return;
    if (reservationWizardDraft) reservationWizardDraft.name = v;
    try { setTimeout(() => reservationWizardOpenStep('phone'), 0); } catch {}
  });
  input.addEventListener('keydown', (e) => {
    if (e.key !== 'Enter') return;
    e.preventDefault();
    reservationWizardNext('customer');
  });
  input.dataset.suggestBound = '1';
}

/* Phone number pad functions */
function phoneNumpadPress(digit) {
  const input = document.getElementById('resWizPhone');
  if (!input) return;
  const current = String(input.value || '');
  if (current.length < 15) { // Limit phone length
    input.value = current + digit;
  }
}

function phoneNumpadBackspace() {
  const input = document.getElementById('resWizPhone');
  if (!input) return;
  const current = String(input.value || '');
  input.value = current.slice(0, -1);
}

function phoneNumpadClear() {
  const input = document.getElementById('resWizPhone');
  if (input) input.value = '';
}

function ensureResWizPhoneAutoAdvanceBound() {
  const input = document.getElementById('resWizPhone');
  if (!input || input.dataset.autoBound) return;
  input.addEventListener('keydown', (e) => {
    if (e.key !== 'Enter') return;
    e.preventDefault();
    reservationWizardFinish();
  });
  input.dataset.autoBound = '1';
}

/* Wizard auto-advance: menu -> company when menu chosen */
function ensureResWizMenuAutoAdvanceBound() {
  const menuEl = document.getElementById('resWizMenu');
  if (!menuEl || menuEl.dataset.bound) return;
  const go = () => {
    const v = String(menuEl.value || '').trim();
    if (!v) return;
    try {
      reservationWizardDraft && (reservationWizardDraft.menu = v);
      setTimeout(() => reservationWizardOpenStep('company'), 0);
    } catch {}
  };
  menuEl.addEventListener('change', go);
  menuEl.addEventListener('blur', go);
  menuEl.dataset.bound = '1';
}

(function initReservationCalendar() {
  const popup = document.getElementById('reservationPopup');
  const cal = document.getElementById('reserveCalendar');
  const grid = document.getElementById('reserveCalGrid');
  const prev = document.getElementById('reserveCalPrev');
  const next = document.getElementById('reserveCalNext');
  const input = document.getElementById('reserveDate');
  if (!popup || !cal || !grid || !prev || !next || !input) return;
  if (popup.dataset.calendarBound) return;

  prev.addEventListener('click', (e) => {
    e.preventDefault();
    setReservationCalendarMonth(-1);
  });
  next.addEventListener('click', (e) => {
    e.preventDefault();
    setReservationCalendarMonth(1);
  });

  grid.addEventListener('click', (e) => {
    const btn = e.target.closest('button[data-date]');
    if (!btn) return;
    const iso = String(btn.dataset.date || '').trim();
    if (!iso) return;

    // If user clicked an out-of-month day, jump to that month.
    const d = new Date(iso + 'T00:00:00');
    if (Number.isFinite(d.getTime())) {
      reservationCalYear = d.getFullYear();
      reservationCalMonth = d.getMonth();
    }
    input.value = iso;
    renderReservationCalendar();

    // Auto-advance to next field after choosing a date.
    try {
      if (typeof reservationSlideIndex === 'number' && reservationSlideIndex === 0) {
        setTimeout(() => setReservationSlide(1), 0);
      }
    } catch (err) {}
  });

  input.addEventListener('change', () => {
    syncReservationCalendarToInput();
  });

  // Initial render
  syncReservationCalendarToInput();
  popup.dataset.calendarBound = '1';
})();

(function initReservationSlider() {
  const popup = document.getElementById('reservationPopup');
  const nextBtn = document.getElementById('reservationNextBtn');
  const prevBtn = document.getElementById('reservationPrevBtn');
  const slider = document.getElementById('reservationSlider');
  const track = document.getElementById('reservationTrack');
  if (!popup || !nextBtn || !prevBtn || !slider || !track) return;

  if (!nextBtn.dataset.bound) {
    nextBtn.addEventListener('click', (e) => {
      e.preventDefault();
      advanceReservationSlide();
    });
    nextBtn.dataset.bound = '1';
  }

  if (!prevBtn.dataset.bound) {
    prevBtn.addEventListener('click', (e) => {
      e.preventDefault();
      setReservationSlide(reservationSlideIndex - 1);
    });
    prevBtn.dataset.bound = '1';
  }

  // Enter advances (except last slide)
  if (!popup.dataset.keyBound) {
    popup.addEventListener('keydown', (e) => {
      if (popup.style.display !== 'flex') return;
      if (e.key !== 'Enter') return;
      const count = getReservationSlidesCount();
      if (reservationSlideIndex >= count - 1) return;
      e.preventDefault();
      advanceReservationSlide();
    });
    popup.dataset.keyBound = '1';
  }

  // Swipe/drag to navigate
  let startX = 0;
  let active = false;
  if (!slider.dataset.swipeBound) {
    slider.addEventListener('pointerdown', (e) => {
      if (popup.style.display !== 'flex') return;

      // Don't hijack pointer events meant for interactive controls.
      const interactive = e.target && (
        e.target.closest('button') ||
        e.target.closest('input') ||
        e.target.closest('select') ||
        e.target.closest('textarea') ||
        e.target.closest('.cal') ||
        e.target.closest('.time-grid') ||
        e.target.closest('.num-pad')
      );
      if (interactive) return;

      active = true;
      startX = e.clientX;
      try { slider.setPointerCapture(e.pointerId); } catch (err) {}
    });
    slider.addEventListener('pointerup', (e) => {
      if (!active) return;
      active = false;
      const dx = e.clientX - startX;
      const threshold = 45;
      if (dx <= -threshold) {
        advanceReservationSlide();
      } else if (dx >= threshold) {
        // Allow swiping back without adding extra buttons
        setReservationSlide(reservationSlideIndex - 1);
      }
    });
    slider.dataset.swipeBound = '1';
  }

  // Initialize state
  setReservationSlide(0);
  popup.dataset.sliderBound = '1';
})();

function closeReceiptPopup() {
  document.getElementById('receiptPopup').style.display = 'none';
}

document.getElementById('reservationForm').addEventListener('submit', function(e) {
  e.preventDefault();
  const date = (document.getElementById('reserveDate').value || '').trim();
  const time = (document.getElementById('reserveTime').value || '').trim();
  const pax = parseInt(document.getElementById('reservePax').value || '0', 10);
  const menu = (document.getElementById('reserveMenu').value || '').trim();
  const company = (document.getElementById('reserveCompany').value || '').trim();
  const name = (document.getElementById('reserveName').value || '').trim();
  const phone = (document.getElementById('reservePhone').value || '').trim();

  // All fields are optional - no validation required

  // Save reservation
  reservations[currentTable] = { name, company, phone, date, time, pax, menu };

  // Persist suggestion lists ("backend" fallback via localStorage)
  try {
    addToStringArrayLS(RES_REF_KEYS.customers, name);
    if (company) addToStringArrayLS(RES_REF_KEYS.companies, company);
    if (menu) addToStringArrayLS(RES_REF_KEYS.menus, menu);
    refreshReservationReferenceData();
  } catch (e) {}
  // New/updated reservation is not occupied until marked arrived.
  setTableOccupiedOverride(currentTable, false);
  // Update display
  updateTableColors();
  closeReservationPopup();
  // Reset form
  this.reset();

  // Reset slider for next open
  setReservationSlide(0);
});

/* --------------------------------------------------
   DIVIDE TABLE MODAL (replaces prompt() flow)
-------------------------------------------------- */
let divideTargetTable = null;

function showDividePopup(tableName) {
  divideTargetTable = tableName;
  const popup = document.getElementById('dividePopup');
  if (!popup) return;

  const nameEl = document.getElementById('divideTableName');
  if (nameEl) nameEl.textContent = tableName;

  const current = getSplitCount(tableName);
  const countEl = document.getElementById('divideCount');
  if (countEl) countEl.value = String(current === 1 ? 2 : current);

  const dirEl = document.getElementById('divideDirection');
  if (dirEl) dirEl.value = (getSplitDirection(tableName) === 'h') ? 'h' : 'v';

  // Render preview
  const countVal = parseInt(String(document.getElementById('divideCount')?.value || '').trim(), 10);
  renderDividePreview(Number.isFinite(countVal) ? countVal : 1, dirEl ? dirEl.value : 'v');

  popup.style.display = 'flex';
}

function closeDividePopup() {
  const popup = document.getElementById('dividePopup');
  if (popup) popup.style.display = 'none';
  divideTargetTable = null;
}

function renderDividePreview(count, dir) {
  const box = document.getElementById('dividePreviewBox');
  if (!box) return;

  const n = Math.max(1, Math.min(6, parseInt(String(count), 10) || 1));
  const d = (String(dir).trim() === 'h') ? 'h' : 'v';

  if (box.replaceChildren) box.replaceChildren();
  else box.innerHTML = '';

  if (d === 'h') {
    box.style.gridTemplateColumns = '1fr';
    box.style.gridTemplateRows = `repeat(${n}, 1fr)`;
  } else {
    box.style.gridTemplateColumns = `repeat(${n}, 1fr)`;
    box.style.gridTemplateRows = '1fr';
  }

  const frag = document.createDocumentFragment();
  for (let i = 0; i < n; i++) {
    const cell = document.createElement('div');
    cell.className = 'divide-preview-cell';
    frag.appendChild(cell);
  }
  box.appendChild(frag);
}

function applyDivideTable(name, count, dir) {
  const cleanDir = (dir === 'h' || dir === 'v') ? dir : 'v';

  ensureTableMemory(name);
  const prev = getSplitCount(name);

  // Prevent shrinking/merging if it would discard items.
  if (prev > 1 && count < prev) {
    normalizeOrdersShape(name);
    const extra = orders[name].slice(count);
    const hasExtraItems = extra.some(p => Array.isArray(p) && p.length > 0);
    if (hasExtraItems) {
      alert('Cannot reduce sections because removed sections still have items.\nClear them first.');
      return false;
    }
  }

  if (count <= 1) {
    if (prev > 1) {
      normalizeOrdersShape(name);
      const extraHasItems = orders[name].slice(1).some(p => Array.isArray(p) && p.length > 0);
      if (extraHasItems) {
        alert('Cannot merge to 1 section because other sections still have items.\nClear them first.');
        return false;
      }
      orders[name] = orders[name][0] || [];
    }

    // Orders shape changed; sync.
    saveOrders();

    delete tableSplits[name];
    delete tableSplitDirections[name];
    saveTableSplits();
    saveTableSplitDirections();

    if (currentTable === name) {
      currentTablePart = 1;
      items = getOrderList(name, 1);
      renderBillTable();
    }

    loadTableMap();
    updateTableColors();
    updateReceiptPreview();
    return true;
  }

  tableSplits[name] = count;
  saveTableSplits();
  tableSplitDirections[name] = cleanDir;
  saveTableSplitDirections();
  normalizeOrdersShape(name);

  // Orders shape changed; sync.
  saveOrders();

  if (currentTable === name) {
    currentTablePart = Math.max(1, Math.min(count, currentTablePart));
    items = getOrderList(name, currentTablePart);
    renderBillTable();
  }

  loadTableMap();
  updateTableColors();
  updateReceiptPreview();
  return true;
}

const divideFormEl = document.getElementById('divideForm');
if (divideFormEl && !divideFormEl.dataset.bound) {
  divideFormEl.addEventListener('submit', function(e) {
    e.preventDefault();
    if (!divideTargetTable) return;

    const count = parseInt(String(document.getElementById('divideCount')?.value || '').trim(), 10);
    const dir = String(document.getElementById('divideDirection')?.value || 'v').trim();

    if (!Number.isFinite(count) || count < 1 || count > 6) {
      alert('Please enter a number between 1 and 6.');
      return;
    }

    const ok = applyDivideTable(divideTargetTable, count, dir);
    if (ok) closeDividePopup();
  });
  divideFormEl.dataset.bound = '1';
}

// Live preview updates
const divideCountEl = document.getElementById('divideCount');
const divideDirectionEl = document.getElementById('divideDirection');
if (divideCountEl && !divideCountEl.dataset.boundPreview) {
  const onChange = () => {
    const count = parseInt(String(divideCountEl.value || '').trim(), 10);
    const dir = String(divideDirectionEl?.value || 'v');
    renderDividePreview(Number.isFinite(count) ? count : 1, dir);
  };
  divideCountEl.addEventListener('input', onChange);
  divideCountEl.addEventListener('change', onChange);
  if (divideDirectionEl) divideDirectionEl.addEventListener('change', onChange);
  divideCountEl.dataset.boundPreview = '1';
}

/* --------------------------------------------------
   SELECT TABLE
-------------------------------------------------- */
function selectTable(t) {
  setActiveTable(t, 1);

  document.querySelectorAll(".floor-table").forEach(el => {
    el.classList.toggle("selected", el.dataset.table === t);
  });

  items = getOrderList(t, currentTablePart);
  renderBillTable();
  updateTableColors();
}

/* --------------------------------------------------
   RENAME TABLE (double-click)
-------------------------------------------------- */
function renameTable(oldName) {
  const newName = prompt("Rename table:", oldName);
  if (newName === null) return;

  const clean = newName.trim();
  if (!clean) {
    alert("Table name cannot be empty.");
    return;
  }
  if (clean === oldName) return;
  if (tableList.includes(clean)) {
    alert("A table with this name already exists.");
    return;
  }

  const idx = tableList.indexOf(oldName);
  if (idx !== -1) tableList[idx] = clean;

  // Move order data
  orders[clean] = orders[oldName] || [];
  delete orders[oldName];
  saveOrders();

  // Move split config
  if (tableSplits[oldName]) {
    tableSplits[clean] = tableSplits[oldName];
    delete tableSplits[oldName];
    saveTableSplits();
  }

  // Move split direction config
  if (tableSplitDirections[oldName]) {
    tableSplitDirections[clean] = tableSplitDirections[oldName];
    delete tableSplitDirections[oldName];
    saveTableSplitDirections();
  }

  // Move occupied override
  if (tableOccupiedOverrides[oldName]) {
    tableOccupiedOverrides[clean] = true;
    delete tableOccupiedOverrides[oldName];
    saveTableOccupiedOverrides();
  }

  // Move position data
  if (tablePositions[oldName]) {
    tablePositions[clean] = tablePositions[oldName];
    delete tablePositions[oldName];
    saveTablePositions();
  }

  // Move size data
  if (tableSizes[oldName]) {
    tableSizes[clean] = tableSizes[oldName];
    delete tableSizes[oldName];
    saveTableSizes();
  }

  if (currentTable === oldName) currentTable = clean;

  saveTableList();
  loadTableMap();
  renderBillTable();
  updateTableColors();
}

/* --------------------------------------------------
   DUPLICATE TABLE (via context menu)
-------------------------------------------------- */
function duplicateTable(baseName) {
  const idx = tableList.indexOf(baseName);
  if (idx === -1) return;

  let suggested = baseName + "_2";
  let newName = prompt('New name for duplicated table:', suggested);
  if (newName === null) return;

  newName = newName.trim();
  if (!newName) {
    alert("Table name cannot be empty.");
    return;
  }
  if (tableList.includes(newName)) {
    alert("A table with that name already exists.");
    return;
  }

  tableList.push(newName);
  ensureTableMemory(newName); // empty bill
  saveTableList();

  // Position: near original
  const basePos = tablePositions[baseName];
  let x = 20, y = 20;
  const grid = document.getElementById("tableGrid");

  if (basePos && typeof basePos.x === "number" && typeof basePos.y === "number") {
    x = basePos.x + 30;
    y = basePos.y + 30;
  }

  if (grid) {
    const maxLeft = grid.clientWidth  - 70;
    const maxTop  = grid.clientHeight - 40;
    if (x < 0) x = 0;
    if (y < 0) y = 0;
    if (x > maxLeft) x = maxLeft;
    if (y > maxTop)  y = maxTop;
  }

  tablePositions[newName] = { x, y };
  saveTablePositions();

  // Copy size if available
  if (tableSizes[baseName]) {
    tableSizes[newName] = { ...tableSizes[baseName] };
    saveTableSizes();
  }

  loadTableMap();
  updateTableColors();
}

/* --------------------------------------------------
   DELETE TABLE (from context menu)
-------------------------------------------------- */
async function deleteTable(name) {
  const hasItems = orders[name] && orders[name].length > 0;
  if (hasItems) {
    const sure = await showConfirmPopup({
      title: 'Delete Table',
      message:
        'Table "' + name + '" has an active bill.\n' +
        'You must clear this bill before deleting.\n\n' +
        'Clear bill and delete table?',
      confirmText: 'Clear Bill + Delete',
      danger: true
    });
    if (!sure) return;

    orders[name] = [];
    saveOrders();
    if (currentTable === name) {
      items = [];
      renderBillTable();
    }
  }

  const ok = await showConfirmPopup({
    title: 'Delete Table',
    message: 'Delete table "' + name + '"?',
    confirmText: 'Delete',
    danger: true
  });
  if (!ok) return;

  const idx = tableList.indexOf(name);
  if (idx !== -1) tableList.splice(idx, 1);

  delete orders[name];
  saveOrders();
  setTableOccupiedOverride(name, false);
  delete tablePositions[name];
  delete tableSizes[name];
  saveTableList();
  saveTablePositions();
  saveTableSizes();

  if (currentTable === name) {
    currentTable = null;
    items = [];
    renderBillTable();
    if (typeof updateReceiptPreview === "function") {
      updateReceiptPreview();
    }
  }

  loadTableMap();
  updateTableColors();
}

/* --------------------------------------------------
   SELECT ALL TABLES
-------------------------------------------------- */
function selectAllTables() {
  document.querySelectorAll('.floor-table').forEach(el => el.classList.add('selected'));
  currentTable = null; // No single current table
  items = [];
  renderBillTable();
  alert('All tables selected.');
}

/* --------------------------------------------------
   MAKE ALL EQUAL SIZE
-------------------------------------------------- */
function makeAllEqualSize() {
  const promptText = 'Enter new size for all tables (width x height, e.g., 80x80):';
  const input = prompt(promptText, '80x80');
  if (!input) return;

  const parts = input.split('x');
  if (parts.length !== 2) {
    alert('Invalid format. Use width x height.');
    return;
  }

  const width = parseInt(parts[0].trim());
  const height = parseInt(parts[1].trim());

  if (isNaN(width) || isNaN(height) || width <= 0 || height <= 0) {
    alert('Invalid dimensions.');
    return;
  }

  tableList.forEach(t => {
    tableSizes[t] = { width, height };
  });
  saveTableSizes();
  loadTableMap();
  alert('All tables resized to ' + width + 'x' + height + '.');
}

/* --------------------------------------------------
   RESIZE SELECTED TABLES
-------------------------------------------------- */
function resizeSelectedTables() {
  const selected = document.querySelectorAll('.floor-table.selected');
  if (selected.length === 0) {
    alert('No tables selected.');
    return;
  }

  const promptText = 'Enter new size for selected tables (width x height, e.g., 80x80):';
  const input = prompt(promptText, '80x80');
  if (!input) return;

  const parts = input.split('x');
  if (parts.length !== 2) {
    alert('Invalid format. Use width x height.');
    return;
  }

  const width = parseInt(parts[0].trim());
  const height = parseInt(parts[1].trim());

  if (isNaN(width) || isNaN(height) || width <= 0 || height <= 0) {
    alert('Invalid dimensions.');
    return;
  }

  selected.forEach(el => {
    const t = el.dataset.table;
    tableSizes[t] = { width, height };
    el.style.width = width + 'px';
    el.style.height = height + 'px';
    // Update scale
    const scale = Math.min(width / 60, height / 60);
    el.style.fontSize = (12 * scale) + 'px';
    el.style.padding = (6 * scale) + 'px';
    el.style.setProperty('--btn-pos', (2 * scale) + 'px');
    el.style.setProperty('--scale', scale);
    // Hide resize handle if too small
    const handle = el.querySelector('.resize-handle');
    if (handle) handle.style.display = scale > 0.5 ? 'block' : 'none';
    el.classList.toggle('compact', scale < 0.75);
  });
  saveTableSizes();
  alert('Selected tables resized to ' + width + 'x' + height + '.');
}

/* --------------------------------------------------
   MAKE SELECTED EQUAL SIZE
-------------------------------------------------- */
function makeSelectedEqualSize() {
  const selected = document.querySelectorAll('.floor-table.selected');
  if (selected.length === 0) {
    alert('No tables selected.');
    return;
  }

  // Use the size of the first selected table
  const firstEl = selected[0];
  const width = firstEl.offsetWidth;
  const height = firstEl.offsetHeight;

  selected.forEach(el => {
    const t = el.dataset.table;
    tableSizes[t] = { width, height };
    el.style.width = width + 'px';
    el.style.height = height + 'px';
    // Update scale
    const scale = Math.min(width / 60, height / 60);
    el.style.fontSize = (12 * scale) + 'px';
    el.style.padding = (6 * scale) + 'px';
    el.style.setProperty('--btn-pos', (2 * scale) + 'px');
    el.style.setProperty('--scale', scale);
    // Hide resize handle if too small
    const handle = el.querySelector('.resize-handle');
    if (handle) handle.style.display = scale > 0.5 ? 'block' : 'none';
    el.classList.toggle('compact', scale < 0.75);
  });
  saveTableSizes();
  alert('Selected tables made equal size: ' + width + 'x' + height + '.');
}

/* --------------------------------------------------
   COPY TABLE
-------------------------------------------------- */
function copyTable(name) {
  const pos = tablePositions[name];
  if (pos) {
    copiedTableData = {
      name: name,
      x: pos.x,
      y: pos.y,
      orders: orders[name] ? [...orders[name]] : []
    };
    alert('Table "' + name + '" copied.');
  } else {
    alert('Table position not found.');
  }
}

/* --------------------------------------------------
   PASTE TABLE
-------------------------------------------------- */
function pasteTable() {
  if (!copiedTableData) {
    alert('No table copied.');
    return;
  }

  let newName = copiedTableData.name + '_copy';
  let counter = 1;
  while (tableList.includes(newName)) {
    newName = copiedTableData.name + '_copy' + counter;
    counter++;
  }

  tableList.push(newName);
  ensureTableMemory(newName);
  orders[newName] = [...copiedTableData.orders];
  saveOrders();

  // Offset position slightly
  tablePositions[newName] = {
    x: copiedTableData.x + 30,
    y: copiedTableData.y + 30
  };

  // Copy size if available
  if (tableSizes[copiedTableData.name]) {
    tableSizes[newName] = { ...tableSizes[copiedTableData.name] };
  }

  saveTableList();
  saveTablePositions();
  saveTableSizes();

  loadTableMap();
  updateTableColors();
  alert('Table pasted as "' + newName + '".');
}

function parseHyphenSplitName(name) {
  const m = /^(.+)-(\d+)$/.exec(String(name || '').trim());
  if (!m) return null;
  const base = m[1];
  const idx = parseInt(m[2], 10);
  if (!base || !Number.isFinite(idx) || idx < 1) return null;
  return { base, idx };
}

// Converts legacy tables like 17A-1, 17A-2 into a single 17A with internal sections.
async function convertHyphenSplitTables(name) {
  const parsed = parseHyphenSplitName(name);
  if (!parsed) {
    alert('This table is not a legacy split name like "17A-1".');
    return;
  }

  const base = parsed.base;
  const parts = tableList
    .map(n => ({ n, p: parseHyphenSplitName(n) }))
    .filter(x => x.p && x.p.base === base)
    .sort((a, b) => a.p.idx - b.p.idx);

  if (parts.length < 2) {
    alert('Found only one part. Nothing to convert.');
    return;
  }
  if (!parts.some(x => x.p.idx === 1)) {
    alert('Cannot convert: missing "' + base + '-1".');
    return;
  }
  if (tableList.includes(base)) {
    alert('Cannot convert: base table already exists: "' + base + '"');
    return;
  }

  const ok = await showConfirmPopup({
    title: 'Convert Split Tables',
    message:
      'Convert these tables into ONE table "' + base + '" with internal sections?\n\n' +
      parts.map(x => x.n).join(', '),
    confirmText: 'Convert',
    danger: true
  });
  if (!ok) return;

  const splitCount = Math.max(...parts.map(x => x.p.idx));
  tableSplits[base] = splitCount;
  saveTableSplits();

  tableSplitDirections[base] = 'v';
  saveTableSplitDirections();

  const firstName = base + '-1';
  const idx1 = tableList.indexOf(firstName);
  if (idx1 === -1) {
    alert('Cannot convert: "' + firstName + '" not found.');
    return;
  }

  // Base table layout: use Base-1's layout.
  if (tablePositions[firstName]) tablePositions[base] = { ...tablePositions[firstName] };
  if (tableSizes[firstName]) tableSizes[base] = { ...tableSizes[firstName] };
  if (reservations[firstName]) reservations[base] = { ...reservations[firstName] };

  // Create base in tableList by renaming Base-1 slot.
  tableList[idx1] = base;

  // Build orders[base] from part tables.
  orders[base] = [];
  for (let i = 0; i < splitCount; i++) orders[base].push([]);

  for (const part of parts) {
    const partName = part.n;
    const partIdx = part.p.idx;
    ensureTableMemory(partName);
    const list = Array.isArray(orders[partName]) ? orders[partName] : [];
    if (partIdx >= 1 && partIdx <= splitCount) orders[base][partIdx - 1] = list;

    // Remove extra tiles (keep the renamed Base-1 slot which is now base)
    if (partName !== firstName) {
      const removeIdx = tableList.indexOf(partName);
      if (removeIdx !== -1) tableList.splice(removeIdx, 1);
    }

    delete orders[partName];
    delete tablePositions[partName];
    delete tableSizes[partName];
    delete reservations[partName];
  }

  // Cleanup old Base-1 layout keys
  delete tablePositions[firstName];
  delete tableSizes[firstName];
  delete reservations[firstName];

  normalizeOrdersShape(base);
  saveOrders();
  saveTableList();
  saveTablePositions();
  saveTableSizes();

  // If you were on one of the old tiles, keep you on the converted base+section.
  if (currentTable && parseHyphenSplitName(currentTable)?.base === base) {
    const old = parseHyphenSplitName(currentTable);
    setActiveTable(base, old?.idx || 1);
  }

  loadTableMap();
  renderBillTable();
  updateTableColors();
  alert('Converted to "' + base + '" with ' + splitCount + ' sections.');
}

// Revert a divided table back to a single (original) table.
// Behavior: can either (1) fully revert to a single section, or (2) merge selected sections.
async function revertSplitTable(name) {
  if (parseHyphenSplitName(name)) {
    alert('This looks like a legacy split table name (e.g. "17A-1").\nUse "Convert Split Tables" first.');
    return;
  }

  const parts = getSplitCount(name);
  if (parts <= 1) {
    alert('This table is not divided.');
    return;
  }

  ensureTableMemory(name);
  normalizeOrdersShape(name);

  const action = await showActionPopup({
    title: 'Revert / Merge Divide',
    message:
      '"' + name + '" has ' + parts + ' sections.\n\n' +
      'Choose what to do:',
    choices: [
      { value: 'merge-some', label: 'Merge selected sections', hint: 'Example: merge 1 and 3 (keep others separate)', variant: 'primary' },
      { value: 'full', label: 'Revert to single section', hint: 'Merge all sections into section 1', variant: 'danger' }
    ],
    cancelText: 'Cancel'
  });

  if (!action) return;

  function fullyRevertToOne() {
    const mergedAll = [];
    for (const part of orders[name]) {
      if (Array.isArray(part) && part.length) mergedAll.push(...part);
    }
    orders[name] = mergedAll;
    delete tableSplits[name];
    delete tableSplitDirections[name];
    saveTableSplits();
    saveTableSplitDirections();

    if (currentTable === name) {
      currentTablePart = 1;
      items = orders[name];
    }
  }

  function mergeSelectedParts(partsToMerge) {
    const oldCount = getSplitCount(name);
    const chosen = Array.from(new Set((partsToMerge || []).map(n => parseInt(String(n), 10)).filter(n => Number.isFinite(n))));
    chosen.sort((a, b) => a - b);

    const valid = chosen.filter(n => n >= 1 && n <= oldCount);
    if (valid.length < 2) {
      alert('Please choose at least 2 valid sections between 1 and ' + oldCount + '.');
      return;
    }

    // Ensure we have the split shape.
    normalizeOrdersShape(name);
    const current = Array.isArray(orders[name]) ? orders[name] : [];
    if (!Array.isArray(current[0])) {
      // Unexpected shape; fall back to full revert.
      fullyRevertToOne();
      return;
    }

    const mergeIdx = valid.map(n => n - 1);
    const targetIdx = mergeIdx[0];

    // Build the merged part and the new parts list.
    const merged = [];
    for (const idx of mergeIdx) {
      const part = current[idx];
      if (Array.isArray(part) && part.length) merged.push(...part);
    }

    const mergeSet = new Set(mergeIdx);
    const nextParts = [];
    for (let i = 0; i < current.length; i++) {
      if (i === targetIdx) {
        nextParts.push(merged);
        continue;
      }
      if (mergeSet.has(i)) continue;
      nextParts.push(Array.isArray(current[i]) ? current[i] : []);
    }

    // Update orders + split settings.
    if (nextParts.length <= 1) {
      orders[name] = merged;
      delete tableSplits[name];
      delete tableSplitDirections[name];
      saveTableSplits();
      saveTableSplitDirections();
    } else {
      orders[name] = nextParts;
      tableSplits[name] = nextParts.length;
      saveTableSplits();
      // keep direction as-is
    }

    // Update currentTablePart mapping if you're viewing this table.
    if (currentTable === name) {
      const oldPart = Math.max(1, Math.min(oldCount, parseInt(String(currentTablePart || 1), 10) || 1));
      let newPart = oldPart;
      if (valid.includes(oldPart)) {
        newPart = targetIdx + 1;
      } else {
        // Shift down by the number of removed parts before this part.
        const removedBefore = valid.filter(p => p !== (targetIdx + 1) && p < oldPart).length;
        newPart = oldPart - removedBefore;
      }
      currentTablePart = Math.max(1, Math.min(nextParts.length, newPart));
      items = getOrderList(name, currentTablePart);
    }
  }

  if (action === 'full') {
    const ok = await showConfirmPopup({
      title: 'Revert Divide',
      message:
        'Revert "' + name + '" back to a single section?\n\n' +
        'All items from sections 2-' + parts + ' will be merged into section 1.',
      confirmText: 'Revert',
      danger: true
    });
    if (!ok) return;
    fullyRevertToOne();
  }

  if (action === 'merge-some') {
    const picked = await promptMergeParts({ tableName: name, partsCount: parts });
    if (!picked) return;
    mergeSelectedParts(picked);
  }

  // Orders shape changed; sync.
  saveOrders();

  loadTableMap();
  if (currentTable === name) renderBillTable();
  updateTableColors();
  updateReceiptPreview();
}

/* --------------------------------------------------
   DIVIDE / SPLIT TABLE
-------------------------------------------------- */
function splitTable(name) {
  // If this is an old legacy split name (e.g. 17A-1), convert it.
  if (parseHyphenSplitName(name)) {
    convertHyphenSplitTables(name);
    return;
  }
  showDividePopup(name);
}

/* --------------------------------------------------
   RESIZE TABLE
-------------------------------------------------- */
function resizeTable(name) {
  const currentSize = tableSizes[name] || { width: 80, height: 80 };
  const promptText = 'Enter new size (width x height, e.g., ' + currentSize.width + 'x' + currentSize.height + '):';
  const input = prompt(promptText, currentSize.width + 'x' + currentSize.height);
  if (!input) return;

  const parts = input.split('x');
  if (parts.length !== 2) {
    alert('Invalid format. Use width x height.');
    return;
  }

  const width = parseInt(parts[0].trim());
  const height = parseInt(parts[1].trim());

  if (isNaN(width) || isNaN(height) || width <= 0 || height <= 0) {
    alert('Invalid dimensions.');
    return;
  }

  tableSizes[name] = { width, height };
  saveTableSizes();
  loadTableMap(); // Re-render to apply new size
}

/* --------------------------------------------------
   UPDATE COLORS (green/red/yellow)
-------------------------------------------------- */
function updateTableColors() {
  document.querySelectorAll(".floor-table").forEach(el => {
    const t = el.dataset.table;
    const hasItems = tableHasAnyItems(t);
    const occupiedOverride = isTableOccupiedOverride(t);
    const needsCleaning = isTableNeedsCleaning(t);
    const hasReservation = reservations[t];
    const isOccupied = hasItems || occupiedOverride;

    el.classList.remove("occupied", "available", "reserved", "needs-cleaning");
    const ui = el._ui;
    const statusEl = ui?.statusEl || el.querySelector('.table-status');
    const etaEl = ui?.etaEl || el.querySelector('.table-eta');
    const menuEl = ui?.menuEl || el.querySelector('.table-menu');
    const paxEl = ui?.paxEl || el.querySelector('.table-pax');
    const billEl = ui?.billEl || el.querySelector('.table-content .bill-amount');
    const overlayEl = ui?.splitOverlayEl || el.querySelector('.split-overlay');

    const arrivedBtnEl = ui?.arrivedBtnEl || el.querySelector('.arrived-btn');

    if (isOccupied) {
      if (!hasItems && needsCleaning) el.classList.add("needs-cleaning");
      else el.classList.add("occupied");
      if (hasItems) {
        const parts = getSplitCount(t);
        statusEl.textContent = "Occupied";
        billEl.style.display = 'block';
        const total = tableTotal(t);
        if (parts > 1) {
          const per = tablePartTotals(t);
          // Render: per-section totals (clusters)
          billEl.textContent = '';
          const bottom = document.createElement('div');
          bottom.className = 'bill-splits';
          per.forEach((v, i) => {
            const pill = document.createElement('span');
            pill.className = 'bill-split-pill';
            pill.textContent = '‡∏ø ' + Number(v || 0).toFixed(0);
            bottom.appendChild(pill);
          });
          billEl.appendChild(bottom);
        } else {
          billEl.textContent = '‡∏ø ' + total.toFixed(0);
        }
      } else {
        statusEl.textContent = needsCleaning ? "Needs cleaning" : "Occupied";
        billEl.style.display = 'none';
      }

      // If this table was reserved, reuse reservation data for display
      if (hasReservation) {
        etaEl.textContent = 'ETA: ' + (hasReservation.time || '');
        paxEl.textContent = 'üë• Pax: ' + (hasReservation.pax || '');
        etaEl.style.display = 'block';
        paxEl.style.display = 'block';
        if (hasReservation.menu) {
          menuEl.textContent = 'Menu: ' + hasReservation.menu;
          menuEl.style.display = 'block';
        } else {
          menuEl.textContent = '';
          menuEl.style.display = 'none';
        }
      } else {
        etaEl.style.display = 'none';
        menuEl.style.display = 'none';
        paxEl.style.display = 'none';
      }
    } else if (hasReservation) {
      el.classList.add("reserved");
      statusEl.textContent = "Reserved";
      etaEl.textContent = "ETA: " + (hasReservation.time || "");
      etaEl.style.display = 'block';
      paxEl.textContent = 'üë• Pax: ' + (hasReservation.pax || '');
      paxEl.style.display = 'block';
      if (hasReservation.menu) {
        menuEl.textContent = 'Menu: ' + hasReservation.menu;
        menuEl.style.display = 'block';
      } else {
        menuEl.textContent = '';
        menuEl.style.display = 'none';
      }
      billEl.style.display = 'none';
    } else {
      el.classList.add("available");
      statusEl.textContent = "Available";
      etaEl.style.display = 'none';
      menuEl.style.display = 'none';
      paxEl.style.display = 'none';
      billEl.style.display = 'none';
    }

    if (arrivedBtnEl) {
      arrivedBtnEl.style.display = (hasReservation && !isOccupied) ? 'inline-flex' : 'none';
    }

    // Split cluster totals (always show per-cluster totals inside each cluster)
    const splitCount = getSplitCount(t);
    if (overlayEl && splitCount > 1) {
      const per = tablePartTotals(t);
      overlayEl.querySelectorAll('.split-cell').forEach(btn => {
        const part = parseInt(btn.dataset.part || '1', 10);
        const v = per[(Number.isFinite(part) ? part : 1) - 1] ?? 0;
        const totalEl = btn.querySelector('.split-cell-total');
        if (totalEl) totalEl.textContent = '‡∏ø ' + Number(v || 0).toFixed(0);
      });
    }
  });
}

/* --------------------------------------------------
   MENU SYSTEM
-------------------------------------------------- */
let menuItems = [];
let items = [];
let customers = [];

function loadMenuGrid() {
  const grid = document.getElementById("menuGrid");
  if (grid.replaceChildren) grid.replaceChildren();
  else grid.innerHTML = "";

  if (!Array.isArray(menuItems)) menuItems = [];

  const fragment = document.createDocumentFragment();
  menuItems.forEach((m, idx) => {
    const div = document.createElement("div");
    div.className = "menu-tile";
    div.dataset.menuIdx = idx;

    const title = document.createElement("div");
    title.className = "menu-title-ko";
    title.textContent = m.korean ?? "";

    const price = document.createElement("div");
    price.className = "menu-price";
    price.textContent = String(m.price ?? "") + " THB";

    div.appendChild(title);
    div.appendChild(price);
    div.addEventListener("click", () => addMenuItem(idx));
    
    // Long press and right-click for quantity popup
    let longPressTimer = null;
    let longPressTriggered = false;
    
    div.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      e.stopPropagation();
      showMenuQtyPopup(idx);
    });
    
    div.addEventListener("touchstart", (e) => {
      longPressTriggered = false;
      longPressTimer = setTimeout(() => {
        longPressTriggered = true;
        showMenuQtyPopup(idx);
      }, 500);
    }, { passive: true });
    
    div.addEventListener("touchend", (e) => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      if (longPressTriggered) {
        e.preventDefault();
        longPressTriggered = false;
      }
    });
    
    div.addEventListener("touchmove", () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    }, { passive: true });
    
    fragment.appendChild(div);
  });
  grid.appendChild(fragment);
}

function addMenuItem(idx) {
  if (!currentTable) {
    alert("Please select a table first.");
    return;
  }

  // If table was marked "Needs cleaning", adding an item means it is in use again.
  try { if (typeof setTableNeedsCleaning === 'function') setTableNeedsCleaning(currentTable, false); } catch (e) {}

  // Get pax count - use as default quantity for walk-ins
  const paxQty = getTablePax(currentTable);
  
  // Use pax as default quantity, or manual qty input if different
  const manualQty = parseInt(document.getElementById("qty").value || "1", 10);
  const qty = (manualQty === 1) ? paxQty : manualQty;
  
  const m = menuItems[idx];

  items.push({
    nameKo: m.korean,
    nameEn: m.english,
    qty: qty,
    unit: m.price,
    total: qty * m.price
  });

  // Visual feedback - flash animation and update badge
  flashMenuTile(idx);
  updateMenuBadges();

  renderBillTable();
  updateTableColors();
  saveOrders();
}

// Flash animation when item is added
function flashMenuTile(idx) {
  const tile = document.querySelector(`.menu-tile[data-menu-idx="${idx}"]`);
  if (!tile) return;
  
  tile.classList.remove('item-added');
  // Force reflow to restart animation
  void tile.offsetWidth;
  tile.classList.add('item-added');
  
  setTimeout(() => tile.classList.remove('item-added'), 400);
}

// Update quantity badges on all menu tiles
function updateMenuBadges() {
  if (!currentTable || !items) return;
  
  // Count quantities per menu item
  const qtyCounts = {};
  items.forEach(item => {
    // Match by Korean name
    const idx = menuItems.findIndex(m => m.korean === item.nameKo);
    if (idx >= 0) {
      qtyCounts[idx] = (qtyCounts[idx] || 0) + item.qty;
    }
  });
  
  // Update badges on all tiles
  document.querySelectorAll('.menu-tile').forEach(tile => {
    const idx = parseInt(tile.dataset.menuIdx, 10);
    let badge = tile.querySelector('.menu-qty-badge');
    const count = qtyCounts[idx] || 0;
    
    if (count > 0) {
      if (!badge) {
        badge = document.createElement('div');
        badge.className = 'menu-qty-badge';
        tile.appendChild(badge);
      }
      badge.textContent = count;
      // Pop animation
      badge.classList.remove('badge-pop');
      void badge.offsetWidth;
      badge.classList.add('badge-pop');
    } else if (badge) {
      badge.remove();
    }
  });
}

/* --------------------------------------------------
   MENU QUANTITY POPUP (long press / right-click)
-------------------------------------------------- */
let menuQtyPopupIndex = null;
let menuQtyPopupPrice = 0;

function showMenuQtyPopup(idx) {
  if (!currentTable) {
    alert("Please select a table first.");
    return;
  }
  
  const m = menuItems[idx];
  if (!m) return;
  
  menuQtyPopupIndex = idx;
  menuQtyPopupPrice = Number(m.price) || 0;
  
  // Get pax count as default quantity
  const defaultQty = getTablePax(currentTable);
  
  const popup = document.getElementById("menuQtyPopup");
  const nameEl = document.getElementById("menuQtyItemName");
  const priceEl = document.getElementById("menuQtyItemPrice");
  const qtyInput = document.getElementById("menuQtyInput");
  const totalEl = document.getElementById("menuQtyTotal");
  
  if (nameEl) nameEl.textContent = m.korean || m.english || "Item";
  if (priceEl) priceEl.textContent = menuQtyPopupPrice + " THB each";
  if (qtyInput) qtyInput.value = String(defaultQty);
  updateMenuQtyTotal();
  
  if (popup) popup.style.display = "flex";
  if (qtyInput) qtyInput.focus();
}

function closeMenuQtyPopup() {
  const popup = document.getElementById("menuQtyPopup");
  if (popup) popup.style.display = "none";
  menuQtyPopupIndex = null;
}

function adjustMenuQty(delta) {
  const qtyInput = document.getElementById("menuQtyInput");
  if (!qtyInput) return;
  
  let val = parseInt(qtyInput.value || "1", 10);
  val = Math.max(1, Math.min(999, val + delta));
  qtyInput.value = val;
  updateMenuQtyTotal();
}

function updateMenuQtyTotal() {
  const qtyInput = document.getElementById("menuQtyInput");
  const totalEl = document.getElementById("menuQtyTotal");
  if (!qtyInput || !totalEl) return;
  
  const qty = Math.max(1, parseInt(qtyInput.value || "1", 10));
  const total = qty * menuQtyPopupPrice;
  totalEl.textContent = "Total: " + total + " THB";
}

function confirmMenuQty() {
  if (menuQtyPopupIndex === null) return;
  if (!currentTable) {
    alert("Please select a table first.");
    closeMenuQtyPopup();
    return;
  }
  
  const qtyInput = document.getElementById("menuQtyInput");
  const qty = Math.max(1, parseInt(qtyInput?.value || "1", 10));
  const m = menuItems[menuQtyPopupIndex];
  
  if (!m) {
    closeMenuQtyPopup();
    return;
  }
  
  // If table was marked "Needs cleaning", adding an item means it is in use again.
  try { if (typeof setTableNeedsCleaning === 'function') setTableNeedsCleaning(currentTable, false); } catch (e) {}
  
  items.push({
    nameKo: m.korean,
    nameEn: m.english,
    qty: qty,
    unit: m.price,
    total: qty * m.price
  });
  
  renderBillTable();
  updateTableColors();
  saveOrders();
  closeMenuQtyPopup();
}

// Update total when quantity input changes
document.addEventListener("DOMContentLoaded", () => {
  const qtyInput = document.getElementById("menuQtyInput");
  if (qtyInput) {
    qtyInput.addEventListener("input", updateMenuQtyTotal);
    qtyInput.addEventListener("change", updateMenuQtyTotal);
  }
  
  // Bill item remove qty input listener
  const billItemRemoveQtyInput = document.getElementById("billItemRemoveQty");
  if (billItemRemoveQtyInput) {
    billItemRemoveQtyInput.addEventListener("input", clampBillItemRemoveQty);
    billItemRemoveQtyInput.addEventListener("change", clampBillItemRemoveQty);
  }
  
  // Discount popup input listeners
  const discountPercentInput = document.getElementById("discountPopupPercent");
  const discountAmountInput = document.getElementById("discountPopupAmount");
  if (discountPercentInput) {
    discountPercentInput.addEventListener("input", () => { 
      document.getElementById("discountPopupAmount").value = "0";
      updateDiscountPreview(); 
    });
  }
  if (discountAmountInput) {
    discountAmountInput.addEventListener("input", () => { 
      document.getElementById("discountPopupPercent").value = "0";
      updateDiscountPreview(); 
    });
  }
});

/* --------------------------------------------------
   BILL ITEM EDIT POPUP (long press / right-click)
-------------------------------------------------- */
let billItemEditData = null; // { key, nameKo, nameEn, unit, qty }

function showBillItemEditPopup(itemData) {
  if (!currentTable) return;
  if (!itemData) return;
  
  billItemEditData = itemData;
  
  const popup = document.getElementById("billItemEditPopup");
  const nameEl = document.getElementById("billItemEditName");
  const infoEl = document.getElementById("billItemEditInfo");
  const qtyInput = document.getElementById("billItemRemoveQty");
  
  if (nameEl) nameEl.textContent = itemData.nameKo || itemData.nameEn || "Item";
  if (infoEl) infoEl.textContent = `Unit: ${itemData.unit} THB √ó ${itemData.qty} = ${Math.round(itemData.qty * itemData.unit)} THB`;
  if (qtyInput) {
    qtyInput.value = "1";
    qtyInput.max = itemData.qty;
  }
  
  if (popup) popup.style.display = "flex";
  if (qtyInput) qtyInput.focus();
}

function closeBillItemEditPopup() {
  const popup = document.getElementById("billItemEditPopup");
  if (popup) popup.style.display = "none";
  billItemEditData = null;
}

function adjustBillItemRemoveQty(delta) {
  const qtyInput = document.getElementById("billItemRemoveQty");
  if (!qtyInput || !billItemEditData) return;
  
  const maxQty = billItemEditData.qty || 1;
  let val = parseInt(qtyInput.value || "1", 10);
  val = Math.max(1, Math.min(maxQty, val + delta));
  qtyInput.value = val;
}

function clampBillItemRemoveQty() {
  const qtyInput = document.getElementById("billItemRemoveQty");
  if (!qtyInput || !billItemEditData) return;
  
  const maxQty = billItemEditData.qty || 1;
  let val = parseInt(qtyInput.value || "1", 10);
  val = Math.max(1, Math.min(maxQty, val));
  qtyInput.value = val;
}

function confirmBillItemRemove() {
  if (!billItemEditData || !currentTable) {
    closeBillItemEditPopup();
    return;
  }
  
  const qtyInput = document.getElementById("billItemRemoveQty");
  const qtyToRemove = Math.max(1, parseInt(qtyInput?.value || "1", 10));
  
  const list = getOrderList(currentTable, currentTablePart);
  removeQtyFromOrderListByKey(list, billItemEditData.key, qtyToRemove);
  items = list;
  
  renderBillTable();
  updateTableColors();
  updateReceiptPreview();
  saveOrders();
  closeBillItemEditPopup();
}

function confirmBillItemRemoveAll() {
  if (!billItemEditData || !currentTable) {
    closeBillItemEditPopup();
    return;
  }
  
  const list = getOrderList(currentTable, currentTablePart);
  removeQtyFromOrderListByKey(list, billItemEditData.key, billItemEditData.qty);
  items = list;
  
  renderBillTable();
  updateTableColors();
  updateReceiptPreview();
  saveOrders();
  closeBillItemEditPopup();
}

/* --------------------------------------------------
   DISCOUNT POPUP
-------------------------------------------------- */
function showDiscountPopup() {
  if (!currentTable) {
    alert("Please select a table first.");
    return;
  }
  
  const popup = document.getElementById("discountPopup");
  const subtotalInfo = document.getElementById("discountSubtotalInfo");
  const percentInput = document.getElementById("discountPopupPercent");
  const amountInput = document.getElementById("discountPopupAmount");
  
  // Calculate current subtotal
  const displayItems = summarizeLineItems(items);
  let subtotal = 0;
  for (const it of displayItems) {
    subtotal += Number(it?.total ?? 0) || 0;
  }
  
  if (subtotalInfo) subtotalInfo.textContent = `Current Subtotal: ${Math.round(subtotal)} THB`;
  
  // Load existing discount values
  const existingPct = parseFloat(document.getElementById("discountPercent")?.value || "0");
  const existingAmt = parseFloat(document.getElementById("discountAmount")?.value || "0");
  
  if (percentInput) percentInput.value = existingPct || "0";
  if (amountInput) amountInput.value = existingAmt || "0";
  
  updateDiscountPreview();
  
  if (popup) popup.style.display = "flex";
}

function closeDiscountPopup() {
  const popup = document.getElementById("discountPopup");
  if (popup) popup.style.display = "none";
}

function setDiscountPercent(pct) {
  const percentInput = document.getElementById("discountPopupPercent");
  const amountInput = document.getElementById("discountPopupAmount");
  if (percentInput) percentInput.value = pct;
  if (amountInput) amountInput.value = "0";
  updateDiscountPreview();
}

function setDiscountAmount(amt) {
  const percentInput = document.getElementById("discountPopupPercent");
  const amountInput = document.getElementById("discountPopupAmount");
  if (amountInput) amountInput.value = amt;
  if (percentInput) percentInput.value = "0";
  updateDiscountPreview();
}

function updateDiscountPreview() {
  const previewEl = document.getElementById("discountPreview");
  if (!previewEl) return;
  
  const displayItems = summarizeLineItems(items);
  let subtotal = 0;
  for (const it of displayItems) {
    subtotal += Number(it?.total ?? 0) || 0;
  }
  
  const pct = parseFloat(document.getElementById("discountPopupPercent")?.value || "0");
  const amt = parseFloat(document.getElementById("discountPopupAmount")?.value || "0");
  
  let discount = 0;
  let discountText = "";
  
  if (pct > 0) {
    discount = subtotal * (pct / 100);
    discountText = `${pct}% off = -${Math.round(discount)} THB`;
  } else if (amt > 0) {
    discount = Math.min(amt, subtotal);
    discountText = `-${Math.round(discount)} THB`;
  } else {
    discountText = "No discount";
  }
  
  const afterDiscount = Math.max(0, subtotal - discount);
  previewEl.innerHTML = `${discountText}<br>After Discount: <strong>${Math.round(afterDiscount)} THB</strong>`;
}

function clearDiscountPopup() {
  const percentInput = document.getElementById("discountPopupPercent");
  const amountInput = document.getElementById("discountPopupAmount");
  if (percentInput) percentInput.value = "0";
  if (amountInput) amountInput.value = "0";
  updateDiscountPreview();
}

function applyDiscountPopup() {
  const pct = parseFloat(document.getElementById("discountPopupPercent")?.value || "0");
  const amt = parseFloat(document.getElementById("discountPopupAmount")?.value || "0");
  
  // Apply to the main discount fields
  const mainPercentInput = document.getElementById("discountPercent");
  const mainAmountInput = document.getElementById("discountAmount");
  
  if (mainPercentInput) mainPercentInput.value = pct > 0 ? pct : "";
  if (mainAmountInput) mainAmountInput.value = amt > 0 ? amt : "";
  
  updateReceiptPreview();
  closeDiscountPopup();
}

/* --------------------------------------------------
   MANUAL MENU ENTRY
-------------------------------------------------- */
function addManualMenuItem() {
  const nameField = document.getElementById("menuName");
  const lines = (nameField?.value || "").split("\n");
  const en = (lines[0] || "").trim();
  const ko = (lines[1] || "").trim();
  const price = parseFloat(document.getElementById("menuPrice").value);

  if (!en && !ko) {
    alert("Enter at least English or Korean name.");
    return;
  }

  if (isNaN(price) || price <= 0) {
    alert("Invalid price.");
    return;
  }

  const item = {
    english: en || ko,
    korean: ko || en,
    price: price
  };

  menuItems.push(item);
  try {
    localStorage.setItem("menuItems", JSON.stringify(menuItems));
  } catch (e) {
    console.error("Failed to save menuItems:", e);
  }

  loadMenuGrid();

  document.getElementById("menuName").value = "";
  document.getElementById("menuPrice").value = "";

  alert("Menu item saved.");
}

/* --------------------------------------------------
   RENDER BILL
-------------------------------------------------- */
function summarizeLineItems(list) {
  const src = Array.isArray(list) ? list : [];
  const map = new Map();

  for (const it of src) {
    const nameKo = String(it?.nameKo ?? "").trim();
    const nameEn = String(it?.nameEn ?? "").trim();
    const unit = Number(it?.unit ?? 0) || 0;
    const qty = Number(it?.qty ?? 0) || 0;
    const total = Number(it?.total ?? (qty * unit)) || 0;

    // Key: same names + same unit price => stack.
    const key = `${nameKo}|${nameEn}|${unit}`;
    const existing = map.get(key);
    if (existing) {
      existing.qty += qty;
      existing.total += total;
    } else {
      map.set(key, {
        nameKo,
        nameEn,
        unit,
        qty,
        total
      });
    }
  }

  return Array.from(map.values());
}

function lineItemKeyFromParts({ nameKo, nameEn, unit }) {
  const ko = String(nameKo ?? "").trim();
  const en = String(nameEn ?? "").trim();
  const u = Number(unit ?? 0) || 0;
  return `${ko}|${en}|${u}`;
}

function removeQtyFromOrderListByKey(list, key, qtyToRemove) {
  if (!Array.isArray(list) || !key) return;
  let remaining = Math.max(0, Number(qtyToRemove ?? 0) || 0);
  if (remaining <= 0) return;

  for (let i = list.length - 1; i >= 0 && remaining > 0; i--) {
    const it = list[i];
    const itKey = lineItemKeyFromParts({ nameKo: it?.nameKo, nameEn: it?.nameEn, unit: it?.unit });
    if (itKey !== key) continue;

    const unit = Number(it?.unit ?? 0) || 0;
    const qty = Number(it?.qty ?? 0) || 0;
    if (qty <= 0) {
      list.splice(i, 1);
      continue;
    }

    if (qty <= remaining) {
      remaining -= qty;
      list.splice(i, 1);
    } else {
      it.qty = qty - remaining;
      it.total = it.qty * unit;
      remaining = 0;
    }
  }
}

function renderBillTable() {
  const tbody = document.querySelector("#billTable tbody");
  if (tbody.replaceChildren) tbody.replaceChildren();
  else tbody.innerHTML = "";

  // Update menu badges when bill changes
  if (typeof updateMenuBadges === 'function') updateMenuBadges();
  const fragment = document.createDocumentFragment();
  const displayItems = summarizeLineItems(items);
  for (const it of displayItems) {
    const tr = document.createElement("tr");
    tr.style.cursor = "pointer";
    
    // Create item data for the edit popup
    const key = lineItemKeyFromParts({ nameKo: it?.nameKo, nameEn: it?.nameEn, unit: it?.unit });
    const itemData = {
      key: key,
      nameKo: it?.nameKo || "",
      nameEn: it?.nameEn || "",
      unit: Number(it?.unit ?? 0) || 0,
      qty: Number(it?.qty ?? 0) || 0
    };

    const tdName = document.createElement("td");
    tdName.textContent = it?.nameKo || it?.nameEn || "";

    const tdQty = document.createElement("td");
    tdQty.textContent = String(it?.qty ?? "");

    const tdTotal = document.createElement("td");
    tdTotal.textContent = String(Math.round(it?.total ?? 0));

    const tdCancel = document.createElement("td");
    tdCancel.style.textAlign = 'right';
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'cancel-item-btn';
    btn.textContent = '‚úï';
    btn.title = 'Cancel item';
    btn.addEventListener('click', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!currentTable) return;

      const qty = Number(it?.qty ?? 0) || 0;
      if (!key || qty <= 0) return;

      const choice = await showActionPopup({
        title: 'Cancel item',
        message: 'Cancel which amount?',
        cancelText: 'Back',
        choices: [
          { value: 'one', label: 'Remove 1', hint: 'Decrease quantity by 1', variant: 'primary' },
          { value: 'all', label: 'Remove all', hint: 'Remove this line completely', variant: 'danger' }
        ]
      });
      if (choice !== 'one' && choice !== 'all') return;

      const list = getOrderList(currentTable, currentTablePart);
      removeQtyFromOrderListByKey(list, key, choice === 'one' ? 1 : qty);
      items = list;
      renderBillTable();
      updateTableColors();
      updateReceiptPreview();
      saveOrders();
    });
    tdCancel.appendChild(btn);
    
    // Long press and right-click for edit popup on the row (excluding the cancel button)
    let longPressTimer = null;
    let longPressTriggered = false;
    
    const openEditPopup = (e) => {
      e.preventDefault();
      e.stopPropagation();
      showBillItemEditPopup(itemData);
    };
    
    tr.addEventListener("contextmenu", openEditPopup);
    
    tr.addEventListener("touchstart", (e) => {
      // Don't trigger long press if touching the cancel button
      if (e.target.closest('.cancel-item-btn')) return;
      longPressTriggered = false;
      longPressTimer = setTimeout(() => {
        longPressTriggered = true;
        showBillItemEditPopup(itemData);
      }, 500);
    }, { passive: true });
    
    tr.addEventListener("touchend", (e) => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      if (longPressTriggered) {
        e.preventDefault();
        longPressTriggered = false;
      }
    });
    
    tr.addEventListener("touchmove", () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    }, { passive: true });

    tr.appendChild(tdName);
    tr.appendChild(tdQty);
    tr.appendChild(tdTotal);
    tr.appendChild(tdCancel);
    fragment.appendChild(tr);
  }
  tbody.appendChild(fragment);

  updateReceiptPreview();
}

/* Clear bill for current table */
function clearBill() {
  if (!currentTable) {
    alert("Select a table first.");
    return;
  }

  const list = getOrderList(currentTable, currentTablePart);
  list.length = 0;
  items = list;

  // If nothing remains on this table, clear manual occupied status and billing mode.
  if (!tableHasAnyItems(currentTable)) {
    if (typeof isTableNeedsCleaning === 'function' && isTableNeedsCleaning(currentTable)) {
      setTableOccupiedOverride(currentTable, true);
    } else {
      setTableOccupiedOverride(currentTable, false);
    }
    // Clear pax when table is fully cleared
    clearTablePax(currentTable);
  }
  renderBillTable();
  updateTableColors();
  saveOrders();
}

</script>

<!-- ============================
     PART 3 ‚Äî RECEIPT + PRINT
     ============================ -->
<script>

const LINE_WIDTH = 37;
const ITEM_COL  = 20;
const QTY_COL   = 5;
const TOTAL_COL = LINE_WIDTH - ITEM_COL - QTY_COL;

let currentPrintMode = "invoice";

/* DEFAULT CUSTOMER */
customers = [{ name: "Walk-in", address: "", taxId: "" }];

/* LOAD MENU FROM LOCALSTORAGE OR DEFAULT */
let storedMenu = localStorage.getItem("menuItems");

if (storedMenu) {
  try {
    const parsed = JSON.parse(storedMenu);
    if (Array.isArray(parsed) && parsed.length > 0) {
      menuItems = parsed;
    }
  } catch (e) {
    menuItems = [];
  }
}

if (!menuItems || menuItems.length === 0) {
  menuItems = [
    { english:"Pork Belly BBQ",       korean:"ÏÇºÍ≤πÏÇ¥",           price:300 },
    { english:"Pork Belly BBQ (HM)",  korean:"ÏÇºÍ≤πÏÇ¥ (ÌóàÎãàÎ¨∏)",  price:330 },
    { english:"Ssambab",              korean:"ÏåàÎ∞•",             price:280 },
    { english:"Ssambab (HM)",         korean:"ÏåàÎ∞• (ÌóàÎãàÎ¨∏)",     price:300 },
    { english:"Suki",                 korean:"ÏàòÎÅº",             price:250 },
    { english:"Suki (HM)",            korean:"ÏàòÎÅº (ÌóàÎãàÎ¨∏)",     price:280 },
    { english:"Nabe",                 korean:"ÎÇòÎ≤†",             price:250 }
  ];
}

/* --------------------------------------------------
   CUSTOMER DROPDOWN
-------------------------------------------------- */
function loadCustomerDropdown() {
  const sel = document.getElementById("customer");
  sel.innerHTML = "";
  customers.forEach((c, idx) => {
    const opt = document.createElement("option");
    opt.value = idx;
    opt.textContent = c.name;
    sel.appendChild(opt);
  });
}

/* --------------------------------------------------
   TOTALS / DISCOUNT
-------------------------------------------------- */
function calculateTotals() {
  let subtotal = items.reduce((sum, it) => sum + it.total, 0);

  const pct = parseFloat(document.getElementById("discountPercent").value || "0");
  const amt = parseFloat(document.getElementById("discountAmount").value || "0");

  let discount = 0;
  if (pct > 0) discount = subtotal * (pct / 100);
  else if (amt > 0) discount = amt;

  if (discount > subtotal) discount = subtotal;

  const gross = subtotal - discount;
  const net   = gross / 1.07;
  const vat   = gross - net;

  return { subtotal, discount, net, vat, gross };
}

function left(text, w = LINE_WIDTH){ return text.padEnd(w, " ").slice(0, w); }
function right(text, w){ return String(text).padStart(w, " ").slice(-w); }
function center(text){
  const leftSpaces = Math.floor((LINE_WIDTH - text.length) / 2);
  return " ".repeat(Math.max(leftSpaces,0)) + text;
}

/* --------------------------------------------------
   RECEIPT PREVIEW
-------------------------------------------------- */
function updateReceiptPreview() {
  const rec = document.getElementById("receipt-text");
  if (!rec) return;

  if (!currentTable) {
    rec.textContent = "Select a table.";
    return;
  }

  if (!items || items.length === 0) {
    rec.textContent = "Table " + currentTable + "\n(No items)";
    return;
  }

  const totals = calculateTotals();
  const guide  = (document.getElementById("guideName").value || "").trim();

  let txt = "";
  txt += center("Heung Boo Ne Garden") + "\n";
  txt += center("Phuket Thailand") + "\n\n";

  // Header: INVOICE / RECEIPT
  txt += center(currentPrintMode.toUpperCase()) + "\n";
  txt += "-".repeat(LINE_WIDTH) + "\n";

  txt += left("Table: " + currentTable) + "\n";
  if (getSplitCount(currentTable) > 1) {
    txt += left("Section: " + currentTablePart + "/" + getSplitCount(currentTable)) + "\n";
  }
  
  // Show pax info
  const tablePax = getTablePax(currentTable);
  if (tablePax > 1) {
    txt += left("Pax: " + tablePax) + "\n";
  }
  
  txt += left("Customer: " + customers[0].name) + "\n";
  if (guide) txt += left("Guide: " + guide) + "\n";

  txt += "-".repeat(LINE_WIDTH) + "\n";
  txt += left("ITEM", ITEM_COL) + right("QTY", QTY_COL) + right("TOTAL", TOTAL_COL) + "\n";
  txt += "-".repeat(LINE_WIDTH) + "\n";

  const displayItems = summarizeLineItems(items);
  displayItems.forEach(it => {
    const qtyStr = "x" + (it.qty ?? 0);
    const totalStr = (Number(it.total ?? 0) || 0).toFixed(0);

    const nameKo = String(it?.nameKo ?? "").trim();
    const nameEn = String(it?.nameEn ?? "").trim();
    const sameName = nameKo && nameEn && nameKo.toLowerCase() === nameEn.toLowerCase();

    if (nameKo && !sameName) {
      txt += left(nameKo) + "\n";
    }

    const primaryName = nameEn || nameKo || "";
    txt += left(primaryName, ITEM_COL) +
           right(qtyStr, QTY_COL) +
           right(totalStr, TOTAL_COL) + "\n\n";
  });

  txt += "-".repeat(LINE_WIDTH) + "\n";

  if (currentPrintMode === "invoice") {
    txt += left("Subtotal", 20)    + right(totals.subtotal.toFixed(2), 16) + "\n";
    txt += left("Discount", 20)    + right(totals.discount.toFixed(2), 16) + "\n";
    txt += left("Before VAT", 20)  + right(totals.net.toFixed(2), 16)      + "\n";
    txt += left("VAT 7%", 20)      + right(totals.vat.toFixed(2), 16)      + "\n";
    txt += left("TOTAL", 20)       + right(totals.gross.toFixed(2), 16)    + "\n";
  } else {
    txt += left("TOTAL", 20)       + right(totals.gross.toFixed(2), 16)    + "\n";
  }

  txt += "-".repeat(LINE_WIDTH) + "\n";
  txt += "Thank you!\n";

  rec.textContent = txt;
}

/* --------------------------------------------------
   PRINT BILL
-------------------------------------------------- */
async function printBill() {
  if (!currentTable) {
    alert("Select table.");
    return;
  }
  if (!items || items.length === 0) {
    alert("No items.");
    return;
  }

  const mode = await showActionPopup({
    title: 'Print',
    message: 'Print as:',
    cancelText: 'Cancel',
    choices: [
      { value: 'invoice', label: 'Invoice', hint: 'Shows VAT + discount breakdown', variant: 'primary' },
      { value: 'receipt', label: 'Receipt', hint: 'Simple total only', variant: 'default' }
    ]
  });
  if (mode !== 'invoice' && mode !== 'receipt') return;
  currentPrintMode = mode;

  updateReceiptPreview();
  window.print();

  const list = getOrderList(currentTable, currentTablePart);
  list.length = 0;
  items = list;

  // Bill cleared after payment -> table needs cleaning.
  try {
    if (typeof setTableNeedsCleaning === 'function') setTableNeedsCleaning(currentTable, true);
  } catch (e) {}

  renderBillTable();
  updateTableColors();
  updateReceiptPreview();
}

/* --------------------------------------------------
   SPLIT PAYMENT (shared + separate items)
   - Works on the CURRENT table + section (currentTable/currentTablePart/items)
   - Lets you mark each line as Shared or Payer 1..N
   - Prints a combined breakdown and optionally clears the bill
-------------------------------------------------- */
function splitIntegerAcross(total, n) {
  const t = Number(total) || 0;
  const count = Math.max(1, n | 0);
  const base = Math.floor(t / count);
  let rem = t - base * count;
  const out = new Array(count).fill(base);
  for (let i = 0; i < out.length && rem > 0; i++, rem--) out[i] += 1;
  return out;
}

function buildSplitPaymentReceiptText(payerCount, assignments) {
  const totals = calculateTotals();
  const guide = (document.getElementById("guideName").value || "").trim();

  const payerItems = Array.from({ length: payerCount }, () => []);
  const sharedItems = [];

  let sharedSubtotal = 0;
  for (let i = 0; i < items.length; i++) {
    const it = items[i];
    const total = Number(it?.total ?? 0) || 0;
    const a = assignments[i];
    if (a === 0) {
      sharedItems.push(it);
      sharedSubtotal += total;
    } else {
      const idx = a - 1;
      if (idx >= 0 && idx < payerCount) payerItems[idx].push(it);
      else {
        sharedItems.push(it);
        sharedSubtotal += total;
      }
    }
  }

  const sharedShares = splitIntegerAcross(sharedSubtotal, payerCount);

  const payerSubtotals = new Array(payerCount).fill(0);
  for (let i = 0; i < payerCount; i++) {
    const specific = payerItems[i].reduce((s, it) => s + (Number(it?.total ?? 0) || 0), 0);
    payerSubtotals[i] = specific + sharedShares[i];
  }

  // Allocate discount proportionally across payers (to keep totals consistent).
  const subtotal = totals.subtotal || 0;
  const gross = totals.gross || 0;
  const payerGross = new Array(payerCount).fill(0);
  if (subtotal > 0) {
    let acc = 0;
    for (let i = 0; i < payerCount; i++) {
      if (i === payerCount - 1) {
        payerGross[i] = +(gross - acc).toFixed(2);
      } else {
        const g = (payerSubtotals[i] / subtotal) * gross;
        payerGross[i] = +g.toFixed(2);
        acc += payerGross[i];
      }
    }
  }

  let txt = "";
  txt += center("Heung Boo Ne Garden") + "\n";
  txt += center("Phuket Thailand") + "\n\n";
  txt += center("SPLIT PAYMENT") + "\n";
  txt += "-".repeat(LINE_WIDTH) + "\n";
  txt += left("Table: " + currentTable) + "\n";
  if (getSplitCount(currentTable) > 1) {
    txt += left("Section: " + currentTablePart + "/" + getSplitCount(currentTable)) + "\n";
  }
  txt += left("Customer: " + customers[0].name) + "\n";
  if (guide) txt += left("Guide: " + guide) + "\n";
  txt += "-".repeat(LINE_WIDTH) + "\n";

  for (let p = 0; p < payerCount; p++) {
    txt += center("PAYER " + (p + 1)) + "\n";
    txt += left("ITEM", ITEM_COL) + right("QTY", QTY_COL) + right("TOTAL", TOTAL_COL) + "\n";
    txt += "-".repeat(LINE_WIDTH) + "\n";

    payerItems[p].forEach(it => {
      const qtyStr = "x" + (it?.qty ?? "");
      const totalStr = (Number(it?.total ?? 0) || 0).toFixed(0);
      if (it?.nameKo) txt += left(it.nameKo) + "\n";
      if (it?.nameEn) {
        txt += left(it.nameEn, ITEM_COL) + right(qtyStr, QTY_COL) + right(totalStr, TOTAL_COL) + "\n";
      } else {
        txt += left("", ITEM_COL) + right(qtyStr, QTY_COL) + right(totalStr, TOTAL_COL) + "\n";
      }
      txt += "\n";
    });

    if (sharedShares[p] > 0) {
      txt += left("Shared items", ITEM_COL) + right("", QTY_COL) + right(String(sharedShares[p]), TOTAL_COL) + "\n";
      txt += "\n";
    }

    txt += "-".repeat(LINE_WIDTH) + "\n";
    txt += left("SUBTOTAL", 20) + right(String(payerSubtotals[p].toFixed(0)), 16) + "\n";
    if ((totals.discount || 0) > 0) {
      const discShare = subtotal > 0 ? ((payerSubtotals[p] / subtotal) * (totals.discount || 0)) : 0;
      txt += left("DISCOUNT", 20) + right(discShare.toFixed(2), 16) + "\n";
    }
    txt += left("TOTAL DUE", 20) + right((payerGross[p] || 0).toFixed(2), 16) + "\n";
    txt += "-".repeat(LINE_WIDTH) + "\n\n";
  }

  if (sharedItems.length > 0) {
    txt += left("Shared item list:") + "\n";
    sharedItems.forEach(it => {
      const totalStr = (Number(it?.total ?? 0) || 0).toFixed(0);
      const label = (it?.nameEn || it?.nameKo || "Item");
      txt += left("- " + label, LINE_WIDTH - 8) + right(totalStr, 8) + "\n";
    });
    txt += "\n";
  }

  txt += center("Thank you!") + "\n";
  return txt;
}

async function printSplitPayment() {
  if (!currentTable) {
    alert("Select table.");
    return;
  }
  if (!items || items.length === 0) {
    alert("No items.");
    return;
  }

  const raw = prompt("Split payment: how many payers? (2-6)", "2");
  if (raw === null) return;
  const payerCount = parseInt(String(raw).trim(), 10);
  if (!Number.isFinite(payerCount) || payerCount < 2 || payerCount > 6) {
    alert("Please enter a number between 2 and 6.");
    return;
  }

  const assignments = new Array(items.length).fill(0); // 0 shared, 1..N payer
  for (let i = 0; i < items.length; i++) {
    const it = items[i];
    const label = (it?.nameEn || it?.nameKo || "Item");
    const totalStr = (Number(it?.total ?? 0) || 0).toFixed(0);

    const a = prompt(
      "Split item " + (i + 1) + "/" + items.length + "\n" +
      label + "\n" +
      "Total: " + totalStr + " THB\n\n" +
      "S = Shared\n" +
      "1-" + payerCount + " = Assign to payer\n\n" +
      "Enter S or a number:",
      "S"
    );
    if (a === null) return;
    const v = String(a).trim();
    if (!v || v.toLowerCase().startsWith('s')) {
      assignments[i] = 0;
      continue;
    }
    const n = parseInt(v, 10);
    if (!Number.isFinite(n) || n < 1 || n > payerCount) {
      alert("Invalid choice. Use S or 1-" + payerCount + ".");
      return;
    }
    assignments[i] = n;
  }

  const txt = buildSplitPaymentReceiptText(payerCount, assignments);
  const rec = document.getElementById("receipt-text");
  if (rec) rec.textContent = txt;
  const prev = document.getElementById('receiptPreview');
  if (prev) prev.textContent = txt;

  const doPrint = await showConfirmPopup({
    title: 'Split Payment',
    message: 'Print split payment breakdown now?',
    confirmText: 'Print',
    danger: false
  });
  if (doPrint) window.print();

  const doClear = await showConfirmPopup({
    title: 'Split Payment',
    message: "Clear this section's bill now?",
    confirmText: 'Clear',
    danger: true
  });
  if (doClear) {
    const list = getOrderList(currentTable, currentTablePart);
    list.length = 0;
    items = list;

    // If nothing left on this table after paying, mark it for cleaning.
    if (!tableHasAnyItems(currentTable)) {
      try { setTableNeedsCleaning(currentTable, true); } catch (e) {}
    }

    renderBillTable();
    updateTableColors();
    updateReceiptPreview();
  }
}

/* --------------------------------------------------
   SELECTIVE PAY (MULTI-TABLE)
   One person pays specific items across multiple tables/sections.
   - Prints one combined receipt
   - Optionally removes only the selected items from each table/section
   Notes: selection is per line item (not partial qty).
-------------------------------------------------- */
function calculateTotalsFromItems(list) {
  const subtotal = (Array.isArray(list) ? list : []).reduce((sum, it) => sum + (Number(it?.total ?? 0) || 0), 0);

  const pct = parseFloat(document.getElementById("discountPercent").value || "0");
  const amt = parseFloat(document.getElementById("discountAmount").value || "0");

  let discount = 0;
  if (pct > 0) discount = subtotal * (pct / 100);
  else if (amt > 0) discount = amt;

  if (discount > subtotal) discount = subtotal;

  const gross = subtotal - discount;
  const net = gross / 1.07;
  const vat = gross - net;

  return { subtotal, discount, net, vat, gross };
}

function formatItemLine(it) {
  const qtyStr = "x" + (it?.qty ?? "");
  const totalStr = (Number(it?.total ?? 0) || 0).toFixed(0);
  const title = (it?.nameEn || it?.nameKo || "Item");
  return {
    title,
    qtyStr,
    totalStr
  };
}

function promptParseNumberList(input, max) {
  const trimmed = String(input || "").trim();
  if (!trimmed) return [];
  if (trimmed.toLowerCase() === 'a' || trimmed.toLowerCase() === 'all') {
    return Array.from({ length: max }, (_, i) => i + 1);
  }
  const parts = trimmed.split(/[,\s]+/).filter(Boolean);
  const nums = [];
  for (const p of parts) {
    const n = parseInt(p, 10);
    if (!Number.isFinite(n) || n < 1 || n > max) return null;
    nums.push(n);
  }
  // de-dupe
  return Array.from(new Set(nums));
}

function getOpenTablesWithItems() {
  return tableList.filter(t => {
    try {
      return tableHasAnyItems(t);
    } catch {
      return false;
    }
  });
}

function collectSectionItems(tableName) {
  ensureTableMemory(tableName);
  const parts = getSplitCount(tableName);
  if (parts > 1) normalizeOrdersShape(tableName);

  const out = [];
  for (let p = 1; p <= parts; p++) {
    const list = getOrderList(tableName, p);
    if (Array.isArray(list) && list.length > 0) {
      out.push({ table: tableName, part: p, list });
    }
  }
  return out;
}

function buildSelectiveMultiTableReceiptText(groups, paidItems) {
  const guide = (document.getElementById("guideName").value || "").trim();
  const totals = calculateTotalsFromItems(paidItems);

  let txt = "";
  txt += center("Heung Boo Ne Garden") + "\n";
  txt += center("Phuket Thailand") + "\n\n";
  txt += center("SELECTIVE PAY") + "\n";
  txt += "-".repeat(LINE_WIDTH) + "\n";
  txt += left("Customer: " + customers[0].name) + "\n";
  if (guide) txt += left("Guide: " + guide) + "\n";
  txt += "-".repeat(LINE_WIDTH) + "\n";

  for (const g of groups) {
    const header = (g.parts > 1) ? (g.table + " (" + g.part + "/" + g.parts + ")") : g.table;
    txt += left("Table: " + header) + "\n";
    txt += left("ITEM", ITEM_COL) + right("QTY", QTY_COL) + right("TOTAL", TOTAL_COL) + "\n";
    txt += "-".repeat(LINE_WIDTH) + "\n";

    g.items.forEach(it => {
      const { qtyStr, totalStr } = formatItemLine(it);
      if (it?.nameKo) txt += left(it.nameKo) + "\n";
      if (it?.nameEn) {
        txt += left(it.nameEn, ITEM_COL) + right(qtyStr, QTY_COL) + right(totalStr, TOTAL_COL) + "\n";
      } else {
        txt += left("", ITEM_COL) + right(qtyStr, QTY_COL) + right(totalStr, TOTAL_COL) + "\n";
      }
      txt += "\n";
    });

    txt += "-".repeat(LINE_WIDTH) + "\n\n";
  }

  if (currentPrintMode === "invoice") {
    txt += left("Subtotal", 20) + right(totals.subtotal.toFixed(2), 16) + "\n";
    txt += left("Discount", 20) + right(totals.discount.toFixed(2), 16) + "\n";
    txt += left("Before VAT", 20) + right(totals.net.toFixed(2), 16) + "\n";
    txt += left("VAT 7%", 20) + right(totals.vat.toFixed(2), 16) + "\n";
    txt += left("TOTAL", 20) + right(totals.gross.toFixed(2), 16) + "\n";
  } else {
    txt += left("TOTAL", 20) + right(totals.gross.toFixed(2), 16) + "\n";
  }

  txt += "-".repeat(LINE_WIDTH) + "\n";
  txt += "Thank you!\n";
  return txt;
}

async function printSelectiveMultiTablePayment() {
  const openTables = getOpenTablesWithItems();
  if (openTables.length === 0) {
    alert("No open items on any table.");
    return;
  }

  const scope = await showActionPopup({
    title: 'Selective Pay',
    message: 'Select scope:',
    cancelText: 'Cancel',
    choices: [
      { value: 'all', label: 'All tables', hint: 'Includes every table with items', variant: 'primary' },
      { value: 'choose', label: 'Choose tables', hint: 'Pick specific table names', variant: 'default' }
    ]
  });
  if (scope !== 'all' && scope !== 'choose') return;

  let tablesToUse = openTables;
  if (scope === 'choose') {
    const raw = prompt(
      "Enter table names separated by commas.\nOpen tables: " + openTables.join(", "),
      openTables.slice(0, 3).join(", ")
    );
    if (raw === null) return;
    const picked = raw.split(/[,\n]+/).map(s => s.trim()).filter(Boolean);
    const uniq = Array.from(new Set(picked));
    const valid = uniq.filter(t => tableList.includes(t));
    if (valid.length === 0) {
      alert("No valid table names selected.");
      return;
    }
    tablesToUse = valid;
  }

  const selectedBySection = []; // { table, part, parts, indices: [0-based], items: [...] }
  const paidItems = [];

  for (const t of tablesToUse) {
    const parts = getSplitCount(t);
    const sections = collectSectionItems(t);
    for (const sec of sections) {
      const list = sec.list;
      if (!Array.isArray(list) || list.length === 0) continue;

      let promptTxt = "";
      promptTxt += "Table " + t + (parts > 1 ? " (Section " + sec.part + "/" + parts + ")" : "") + "\n";
      promptTxt += "Choose items to pay (leave blank to skip)\n";
      promptTxt += "Type: A = all, or numbers like 1,3,4\n\n";
      for (let i = 0; i < list.length; i++) {
        const it = list[i];
        const { title, qtyStr, totalStr } = formatItemLine(it);
        promptTxt += (i + 1) + ") " + title + " " + qtyStr + " = " + totalStr + "\n";
      }

      const ans = prompt(promptTxt, "");
      if (ans === null) return;
      const chosen = promptParseNumberList(ans, list.length);
      if (chosen === null) {
        alert("Invalid selection. Use A or item numbers.");
        return;
      }
      if (chosen.length === 0) continue;

      const indices = chosen.map(n => n - 1);
      const pickedItems = indices.map(i => list[i]).filter(Boolean);
      if (pickedItems.length === 0) continue;

      selectedBySection.push({ table: t, part: sec.part, parts, indices, items: pickedItems });
      paidItems.push(...pickedItems);
    }
  }

  if (paidItems.length === 0) {
    alert("No items selected.");
    return;
  }

  const mode = await showActionPopup({
    title: 'Selective Pay',
    message: 'Print as:',
    cancelText: 'Cancel',
    choices: [
      { value: 'invoice', label: 'Invoice', hint: 'Shows VAT + discount breakdown', variant: 'primary' },
      { value: 'receipt', label: 'Receipt', hint: 'Simple total only', variant: 'default' }
    ]
  });
  if (mode !== 'invoice' && mode !== 'receipt') return;
  currentPrintMode = mode;

  const txt = buildSelectiveMultiTableReceiptText(selectedBySection, paidItems);
  const rec = document.getElementById("receipt-text");
  if (rec) rec.textContent = txt;
  const prev = document.getElementById('receiptPreview');
  if (prev) prev.textContent = txt;
  document.getElementById('receiptPopup').style.display = 'flex';

  const doPrint = await showConfirmPopup({
    title: 'Selective Pay',
    message: 'Print this selective-payment bill now?',
    confirmText: 'Print',
    danger: false
  });
  if (doPrint) window.print();

  const doClear = await showConfirmPopup({
    title: 'Selective Pay',
    message: 'Remove only the PAID items from each table now?',
    confirmText: 'Remove Paid Items',
    danger: true
  });
  if (doClear) {
    for (const sel of selectedBySection) {
      const list = getOrderList(sel.table, sel.part);
      const toRemove = Array.from(new Set(sel.indices)).sort((a, b) => b - a);
      for (const idx of toRemove) {
        if (idx >= 0 && idx < list.length) list.splice(idx, 1);
      }
      // If table now empty after paying, mark it for cleaning.
      if (!tableHasAnyItems(sel.table)) {
        try { setTableNeedsCleaning(sel.table, true); } catch (e) {}
      }
    }

    // Refresh current view
    if (currentTable) {
      items = getOrderList(currentTable, currentTablePart);
      renderBillTable();
    }
    updateTableColors();
    updateReceiptPreview();
  }
}

/* --------------------------------------------------
   INIT
-------------------------------------------------- */
async function initPOS() {
  // Pull persisted layout state from backend first (cross-device), then build UI.
  try { await (window.loadPosStateFromBackend && window.loadPosStateFromBackend()); } catch {}

  loadTableMap();
  loadMenuGrid();
  loadCustomerDropdown();
  try { loadReservationsFromBackend(); } catch {}
  initTableContextMenu();
  updateReceiptPreview();
}

window.addEventListener("DOMContentLoaded", initPOS, { once: true });

</script>

<!-- Integration layer: backend API + realtime sync -->
<script src="/socket.io/socket.io.js"></script>
<script>
// Uses same-origin backend when POS is served from the backend.
// If you open the POS via file:// this won't work; use http://localhost:4000/pos%20(1).html
const API_BASE = `${location.origin}/api`;

function posLocalISODate(d = new Date()) {
  // Format local date as YYYY-MM-DD without UTC shifting.
  const offsetMs = d.getTimezoneOffset() * 60000;
  return new Date(d.getTime() - offsetMs).toISOString().slice(0, 10);
}

async function apiGet(path) {
  const res = await fetch(API_BASE + path, { headers: { 'Content-Type': 'application/json' } });
  if (!res.ok) throw new Error(await res.text());
  return res.json();
}

async function apiPost(path, body) {
  const res = await fetch(API_BASE + path, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body || {})
  });
  if (!res.ok) throw new Error(await res.text());
  return res.json();
}

async function apiPut(path, body) {
  const res = await fetch(API_BASE + path, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body || {})
  });
  if (!res.ok) throw new Error(await res.text());
  return res.json();
}

// -------------------------------
// POS State (cross-device sync)
// -------------------------------

function safeSetLS(key, value) {
  try {
    localStorage.setItem(key, JSON.stringify(value));
  } catch {}
}

function applyPosStateToGlobals(state) {
  if (!state || typeof state !== 'object') return;

  // Objects
  if (state.tablePositions && typeof state.tablePositions === 'object') tablePositions = state.tablePositions;
  if (state.tableSizes && typeof state.tableSizes === 'object') tableSizes = state.tableSizes;
  if (state.tableSplits && typeof state.tableSplits === 'object') tableSplits = state.tableSplits;
  if (state.tableSplitDirections && typeof state.tableSplitDirections === 'object') tableSplitDirections = state.tableSplitDirections;
  if (state.tableOccupiedOverrides && typeof state.tableOccupiedOverrides === 'object') tableOccupiedOverrides = state.tableOccupiedOverrides;
  if (state.tableNeedsCleaning && typeof state.tableNeedsCleaning === 'object') tableNeedsCleaning = state.tableNeedsCleaning;

  // Arrays
  if (Array.isArray(state.tableList) && state.tableList.length > 0) tableList = state.tableList;

  // Orders (table bills)
  if (state.orders && typeof state.orders === 'object' && !Array.isArray(state.orders)) orders = state.orders;
}

async function loadPosStateFromBackend() {
  try {
    // Only works when served from http(s) backend (same-origin).
    const res = await apiGet('/pos-state');
    const state = res?.state;
    if (!state || typeof state !== 'object') return;

    applyPosStateToGlobals(state);

    // Mirror into localStorage so other pages (like reservations.html) can still read it.
    if (state.tablePositions) safeSetLS('tablePositions', state.tablePositions);
    if (state.tableSizes) safeSetLS('tableSizes', state.tableSizes);
    if (state.tableSplits) safeSetLS('tableSplits', state.tableSplits);
    if (state.tableSplitDirections) safeSetLS('tableSplitDirections', state.tableSplitDirections);
    if (state.tableOccupiedOverrides) safeSetLS('tableOccupiedOverrides', state.tableOccupiedOverrides);
    if (state.tableNeedsCleaning) safeSetLS('tableNeedsCleaning', state.tableNeedsCleaning);
    if (state.tableList) safeSetLS('tableList', state.tableList);
    if (state.orders) safeSetLS('orders', state.orders);
  } catch {
    // backend not available; fall back to localStorage
  }
}

let posStateSyncTimer = null;
let posStatePending = {};

function schedulePosStateSync(patch) {
  if (!patch || typeof patch !== 'object') return;
  posStatePending = { ...posStatePending, ...patch };

  if (posStateSyncTimer) clearTimeout(posStateSyncTimer);
  posStateSyncTimer = setTimeout(async () => {
    const toSend = posStatePending;
    posStatePending = {};
    posStateSyncTimer = null;
    try {
      await apiPut('/pos-state', { state: toSend });
    } catch {
      // no-op; localStorage still has state
    }
  }, 400);
}

window.loadPosStateFromBackend = loadPosStateFromBackend;
window.schedulePosStateSync = schedulePosStateSync;

function escapeHtml(s) {
  return String(s ?? '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function isReservedSidebarOpen() {
  return document.getElementById('reservedSidebar')?.classList?.contains('open');
}

let reservedSidebarScope = 'today'; // 'today' | 'all'

function syncReservedScopeBtn() {
  const btn = document.getElementById('reservedScopeBtn');
  if (!btn) return;
  btn.textContent = reservedSidebarScope === 'all' ? 'Today' : 'All Dates';
}

function toggleReservedScope() {
  reservedSidebarScope = reservedSidebarScope === 'all' ? 'today' : 'all';
  syncReservedScopeBtn();
  refreshReservedSidebar();
}

function syncReservedToggleBtn() {
  const btn = document.getElementById('reservedToggleBtn');
  if (!btn) return;
  const open = isReservedSidebarOpen();
  btn.classList.toggle('open', open);
  btn.textContent = open ? '‚Äπ' : '‚Ä∫';
  btn.setAttribute('aria-label', open ? 'Close reserved sidebar' : 'Open reserved sidebar');
}

function openReservedSidebar() {
  const backdrop = document.getElementById('reservedSidebarBackdrop');
  const panel = document.getElementById('reservedSidebar');
  if (!backdrop || !panel) return;
  backdrop.style.display = 'block';
  panel.classList.add('open');
  syncReservedToggleBtn();
  syncReservedScopeBtn();
  refreshReservedSidebar();
}

function closeReservedSidebar() {
  const backdrop = document.getElementById('reservedSidebarBackdrop');
  const panel = document.getElementById('reservedSidebar');
  if (backdrop) backdrop.style.display = 'none';
  if (panel) panel.classList.remove('open');
  syncReservedToggleBtn();
}

function toggleReservedSidebar() {
  if (isReservedSidebarOpen()) closeReservedSidebar();
  else openReservedSidebar();
}

function reservedDisplayDate(dateStr) {
  // dateStr: YYYY-MM-DD
  try {
    const [y, m, d] = String(dateStr).split('-').map(n => parseInt(n, 10));
    if (!y || !m || !d) return String(dateStr);
    const dt = new Date(y, m - 1, d);
    return dt.toLocaleDateString(undefined, { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' });
  } catch {
    return String(dateStr);
  }
}

function renderReservedItems(container, items, kind, showDate) {
  if (!container) return;
  const list = Array.isArray(items) ? items : [];
  if (!list.length) {
    container.innerHTML = `<div class="reserved-empty">No ${escapeHtml(kind)} for today.</div>`;
    return;
  }

  // Sort by date (optional) then time then table
  const sorted = list
    .slice()
    .sort((a, b) => {
      if (showDate) {
        const da = String(a?.date ?? '');
        const db = String(b?.date ?? '');
        if (da !== db) return da.localeCompare(db);
      }
      const ta = String(a?.time ?? '99:99');
      const tb = String(b?.time ?? '99:99');
      if (ta !== tb) return ta.localeCompare(tb);
      const sa = String(a?.table ?? '');
      const sb = String(b?.table ?? '');
      return sa.localeCompare(sb, undefined, { numeric: true, sensitivity: 'base' });
    });

  container.innerHTML = sorted
    .map(it => {
      const time = String(it?.time ?? '').trim();
      const table = String(it?.table ?? '').trim();
      const paxRaw = (it?.pax != null ? it.pax : (it?.partySize != null ? it.partySize : ''));
      const pax = paxRaw != null && String(paxRaw).trim() !== '' ? String(paxRaw).trim() : '';
      const customer = String(it?.customerName ?? it?.name ?? '').trim();
      const phone = String(it?.phone ?? '').trim();
      const company = String(it?.companyName ?? it?.company ?? '').trim();
      const menu = String(it?.menu ?? '').trim();
      const notes = String(it?.notes ?? '').trim();
      const date = String(it?.date ?? '').trim();

      const kv = [];
      if (customer) kv.push(`<div><b>Customer:</b> ${escapeHtml(customer)}</div>`);
      if (phone) kv.push(`<div><b>Phone:</b> ${escapeHtml(phone)}</div>`);
      if (company) kv.push(`<div><b>Company:</b> ${escapeHtml(company)}</div>`);
      if (menu) kv.push(`<div><b>Menu:</b> ${escapeHtml(menu)}</div>`);
      if (notes) kv.push(`<div><b>Notes:</b> ${escapeHtml(notes)}</div>`);

      const leftPieces = [];
      if (showDate && date) leftPieces.push(reservedDisplayDate(date));
      leftPieces.push(time || '‚Äî');
      if (pax) leftPieces.push(`‚Ä¢ ${escapeHtml(pax)} pax`);
      const left = leftPieces.filter(Boolean).join(' ');
      const right = table ? `Table ${escapeHtml(table)}` : '‚Äî';

      return `
        <div class="reserved-item">
          <div class="reserved-item-top">
            <div class="left">${escapeHtml(left)}</div>
            <div class="right">${right}</div>
          </div>
          <div class="reserved-kv">${kv.join('') || `<div class="reserved-empty">No details</div>`}</div>
        </div>
      `;
    })
    .join('');
}

async function refreshReservedSidebar() {
  const showAll = reservedSidebarScope === 'all';
  const date = showAll ? '' : posLocalISODate();
  const sub = document.getElementById('reservedSidebarSub');
  if (sub) sub.textContent = showAll ? 'All dates' : reservedDisplayDate(date);

  const resBox = document.getElementById('reservedReservations');
  const bookBox = document.getElementById('reservedBookings');

  try {
    const reservationsPath = showAll ? '/reservations' : `/reservations?date=${encodeURIComponent(date)}`;
    const bookingsPath = showAll ? '/bookings' : `/bookings?date=${encodeURIComponent(date)}`;

    const [reservationsRes, bookingsRes] = await Promise.all([
      apiGet(reservationsPath),
      apiGet(bookingsPath)
    ]);

    const reservations = Array.isArray(reservationsRes?.items) ? reservationsRes.items : [];
    const bookings = Array.isArray(bookingsRes?.items) ? bookingsRes.items : [];

    renderReservedItems(resBox, reservations, 'reservations', showAll);
    renderReservedItems(bookBox, bookings, 'bookings', showAll);
  } catch (e) {
    console.warn('Reserved sidebar refresh failed:', e);
    if (resBox) resBox.innerHTML = `<div class="reserved-empty">Failed to load reservations.</div>`;
    if (bookBox) bookBox.innerHTML = `<div class="reserved-empty">Failed to load bookings.</div>`;
  }
}

// Backend reservations -> POS reservations{} (table map status)
async function loadReservationsFromBackend(date = posLocalISODate()) {
  try {
    const data = await apiGet(`/reservations?date=${encodeURIComponent(date)}`);
    const backendItems = Array.isArray(data.items) ? data.items : [];

    const byTable = {};
    for (const r of backendItems) {
      const table = String(r?.table ?? '').trim();
      if (!table) continue;

      const candidate = {
        id: String(r?.id ?? '').trim(),
        name: String(r?.customerName ?? '').trim(),
        company: String(r?.companyName ?? '').trim(),
        phone: String(r?.phone ?? '').trim(),
        date: String(r?.date ?? date).trim(),
        time: String(r?.time ?? '').trim(),
        pax: Number.isFinite(+r?.pax) ? (parseInt(r.pax, 10) || 0) : 0,
        menu: String(r?.menu ?? '').trim(),
        notes: String(r?.notes ?? '').trim(),
        source: 'backend'
      };

      const existing = byTable[table];
      if (!existing) {
        byTable[table] = candidate;
      } else {
        // If multiple reservations exist for a table on the same day, keep the earliest time.
        const a = existing.time || '99:99';
        const b = candidate.time || '99:99';
        if (b < a) byTable[table] = candidate;
      }
    }

    // Source of truth for the table map = today's backend reservations.
    reservations = byTable;
    updateTableColors();
  } catch (e) {
    console.warn('Backend reservations load failed:', e);
  }
}

// Backend menu -> POS menuItems[] shape: { english, korean, price }
if (typeof loadMenuGrid === 'function') {
  const originalLoadMenuGrid = loadMenuGrid;
  window.loadMenuGrid = async function() {
    try {
      const data = await apiGet('/menu');
      const backendItems = Array.isArray(data.items) ? data.items : [];

      // Map backend items to the existing POS structure.
      menuItems = backendItems
        .map(m => {
          const name = String(m?.name ?? '').trim();
          const price = Number(m?.price ?? 0) || 0;
          if (!name) return null;
          return { english: name, korean: name, price };
        })
        .filter(Boolean);

      return originalLoadMenuGrid();
    } catch (e) {
      console.warn('Backend menu load failed, using local menu:', e);
      try { return originalLoadMenuGrid(); } catch {}
    }
  };
}

// Save POS manual menu entry into backend (so all devices sync)
if (typeof addManualMenuItem === 'function') {
  const originalAddManualMenuItem = addManualMenuItem;
  window.addManualMenuItem = async function() {
    try {
      const en = (document.getElementById('menuEnglish')?.value || '').trim();
      const ko = (document.getElementById('menuKorean')?.value || '').trim();
      const priceRaw = document.getElementById('menuPrice')?.value;
      const price = Number(priceRaw);
      const name = en || ko;

      if (!name) {
        alert('Enter at least Korean or English name.');
        return;
      }
      if (!Number.isFinite(price) || price <= 0) {
        alert('Invalid price.');
        return;
      }

      await apiPost('/menu', { name, price, category: '', description: '' });

      // Clear inputs
      const enEl = document.getElementById('menuEnglish');
      const koEl = document.getElementById('menuKorean');
      const priceEl = document.getElementById('menuPrice');
      if (enEl) enEl.value = '';
      if (koEl) koEl.value = '';
      if (priceEl) priceEl.value = '';

      await loadMenuGrid();
      alert('Menu item saved.');
    } catch (e) {
      console.warn('Failed to save menu item to backend, falling back to localStorage:', e);
      try { return originalAddManualMenuItem(); } catch {}
    }
  };
}

// Backend customers -> POS customers[] (dropdown currently not used by printing, but keep it synced)
if (typeof loadCustomerDropdown === 'function') {
  const originalLoadCustomerDropdown = loadCustomerDropdown;
  window.loadCustomerDropdown = async function() {
    try {
      const data = await apiGet('/customers');
      const backendCustomers = Array.isArray(data.items) ? data.items : [];
      customers = [{ name: 'Walk-in', address: '', taxId: '' }].concat(
        backendCustomers
          .map(c => {
            const name = String(c?.name ?? '').trim();
            if (!name) return null;
            return { name, address: c?.address || '', taxId: c?.taxId || '' };
          })
          .filter(Boolean)
      );
      return originalLoadCustomerDropdown();
    } catch (e) {
      console.warn('Backend customers load failed, using local:', e);
      try { return originalLoadCustomerDropdown(); } catch {}
    }
  };
}

// Realtime updates: refresh the POS menu + customers when admin changes them
try {
  const socket = io();
  socket.on('data:update', ({ topic }) => {
    if (topic === 'menu') {
      try { loadMenuGrid(); } catch {}
    }
    if (topic === 'customers') {
      try { loadCustomerDropdown(); } catch {}
    }
    if (topic === 'reservations') {
      try { loadReservationsFromBackend(); } catch {}
      if (isReservedSidebarOpen()) {
        try { refreshReservedSidebar(); } catch {}
      }
    }
    if (topic === 'bookings') {
      if (isReservedSidebarOpen()) {
        try { refreshReservedSidebar(); } catch {}
      }
    }
    if (topic === 'posState') {
      // Another device changed table layout/state - reload from backend
      try {
        loadPosStateFromBackend().then(() => {
          loadTableMap();
          updateTableColors();
          if (currentTable) {
            // Keep the bill panel in sync when orders change.
            currentTablePart = Math.max(1, Math.min(getSplitCount(currentTable), currentTablePart || 1));
            items = getOrderList(currentTable, currentTablePart);
            try { renderBillTable(); } catch {}
            try { updateReceiptPreview(); } catch {}
          }
        });
      } catch {}
    }
  });

  // Listen for table selection updates from other clients
  socket.on('tableSelection', ({ selectedTables: remoteTables }) => {
    try {
      selectedTables.clear();
      remoteTables.forEach(table => selectedTables.add(table));
      updateTableSelections();
    } catch (e) {
      console.warn('Error updating table selections', e);
    }
  });

  // Listen for table size updates from other clients
  socket.on('tableSizesUpdate', ({ tableSizes: remoteSizes }) => {
    try {
      Object.assign(tableSizes, remoteSizes);
      saveTableSizes();
      loadTableMap();
    } catch (e) {
      console.warn('Error updating table sizes', e);
    }
  });

  // Make socket globally available
  window.socket = socket;
} catch (e) {
  console.warn('Socket.IO unavailable', e);
}
</script>

</body>
</html>
